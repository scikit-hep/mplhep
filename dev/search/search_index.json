{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mplhep","text":"<p>A matplotlib wrapper for easy plotting required in high energy physics (HEP). Primarily \"prebinned\" 1D &amp; 2D histograms and matplotlib style-sheets carrying recommended plotting styles of large LHC experiments - ATLAS, CMS &amp; LHCb. This project is published on GitHub.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>Install mplhep using pip:</p> <pre><code>pip install mplhep\n</code></pre>"},{"location":"#simple-example","title":"Simple Example","text":"<p>Here's a quick example showing the primary functionality</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use() # Style reset to default\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\ntxt_obj = mh.add_text(\"Default\", loc='over left')\nmh.append_text(\"matplotlib style\", txt_obj, loc='right')\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"plothist\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\ntxt_obj = mh.add_text(\"plothist\", loc='over left')\nmh.append_text(\"style\", txt_obj, loc='right', fontsize='small')\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"CMS\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\nmh.cms.label(\"Preliminary\", data=False, lumi=100, com=15) # ax can be implicit\n# mh.mpl_magic(soft_fail=True)  # Autofit label - not needed\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"ATLAS\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\nmh.atlas.label(\"Preliminary\", data=False, lumi=100, com=15) # ax can be implicit\nmh.mpl_magic(soft_fail=True) # Autofit label\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"LHCb2\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\nmh.lhcb.label(\"Preliminary\", data=False, lumi=100, com=15) # ax can be implicit\nmh.mpl_magic(soft_fail=True) # Autofit label\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"ALICE\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\nmh.alice.label(\"Preliminary\", data=False, lumi=100, com=15) # ax can be implicit\nmh.mpl_magic(soft_fail=True) # Autofit label\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport mplhep as mh\nimport numpy as np\nnp.random.seed(42)\n# Set the plotting style\nmh.style.use(\"DUNE\")\n\n# Create a plot\nfig, ax = plt.subplots()\n# Plot a pre-binned histogram\nmh.histplot(*np.histogram(np.random.normal(0, 1, 1000)), ax=ax, label=\"Data\")\n# Add appropriate labels\nmh.dune.label(\"Preliminary\", data=False, lumi=100, com=15) # ax can be implicit\n# mh.mpl_magic(soft_fail=True)  # Autofit label - not needed\n</code></pre> <p>This creates a simple histogram with HEP-style formatting. Check out the User Guide and the Gallery below for more advanced examples!</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>Step-by-step instructions on how to use mplhep for your HEP plotting needs, explaining key features and functionalities.</p>"},{"location":"#gallery","title":"Gallery","text":"<p>A collection of example plots created using mplhep, showcasing various plot types.</p>"},{"location":"#api","title":"API","text":"<p>Comprehensive reference documentation for all functions, classes, and modules in mplhep.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>A guide to contributing to the mplhep project, including setup instructions and coding guidelines.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Check the GitHub repository for issues</li> <li>Ask questions in the scikit-hep discussions</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to mplhep","text":"<p>We are happy to accept contributions to <code>mplhep</code> via Pull Requests to the GitHub repo. To get started fork the repo.</p>"},{"location":"CONTRIBUTING/#bug-reports","title":"Bug Reports","text":"<p>Please open an issue.</p>"},{"location":"CONTRIBUTING/#installing-the-development-environment","title":"Installing the development environment","text":"<p><pre><code>python -m pip install --upgrade --editable \".[all]\"\n</code></pre> Also conveniently accessible as <code>bash install.sh</code>.</p>"},{"location":"CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"CONTRIBUTING/#pull-requests-procedure","title":"Pull Requests Procedure","text":"<p>If you would like to make a pull request please:</p> <ol> <li>Make a fork of the project</li> <li>Clone your fork locally</li> <li>Install <code>prek</code> and the project's <code>pre-commit</code> hooks</li> <li>Test your changes with <code>pytest</code></li> <li>Commit your changes to a feature branch of your fork, push to your branch</li> <li>Make a PR</li> </ol>"},{"location":"CONTRIBUTING/#running-the-tests","title":"Running the tests","text":"<p>You can run the unit tests (which should be fast!) via the following command:</p> <p>With  pytest</p> <pre><code>pytest --mpl --ignore=tests/test_notebooks.py\n</code></pre> <p>Note: This ignores the notebook tests (which are run via papermill) and run somewhat slow.</p> <p>Make sure to run the complete suite before submitting a PR</p> <pre><code>python -m pytest -r sa --mpl --mpl-results-path=pytest_results -n 4\n</code></pre> <p>With  nox</p> <pre><code>nox -s tests\n</code></pre>"},{"location":"CONTRIBUTING/#making-a-pull-request","title":"Making a pull request","text":"<p>We follow Conventional Commit for commit messages and PR titles. Since we merge PR's using squash commits, it's fine if the final commit messages (proposed in the PR body) follow this convention.</p>"},{"location":"CONTRIBUTING/#generating-reference-visuals","title":"Generating Reference Visuals","text":"<p>If you modified expected outcomes of the tests. New baseline visuals can be generated using this command:</p> <p>With  pytest</p> <pre><code> python -m pytest -r sa --mpl -n 4 --mpl-generate-path=tests/baseline\n</code></pre> <p>With  nox</p> <pre><code> nox -s generate_examples_figures\n</code></pre> <p>Only include the actually modified baseline images in your PR! Running <code>git add -a</code> and the like will sometimes result in including images which are visually identically but not the same bit-wise.</p>"},{"location":"CONTRIBUTING/#linting-and-formatting","title":"Linting and Formatting","text":"<p>We use <code>prek</code> to manage code formatting and linting. Make sure to run it before committing your changes:</p> <p>With  prek</p> <pre><code>prek run --all-files\n</code></pre> <p>With  nox</p> <pre><code>nox -s lint\n</code></pre>"},{"location":"CONTRIBUTING/#contributing-to-the-documentation","title":"Contributing to the documentation","text":"<p>The documentation is built using MkDocs and the Material for MkDocs theme. To contribute to the documentation, please look at the <code>new_docs/CONTRIBUTING_DOC.md</code> file for instructions.</p>"},{"location":"CONTRIBUTING_DOC/","title":"Documentation","text":"<p>The documentation for <code>mplhep</code> is built using MkDocs with the Material for MkDocs theme.</p> <p>To build the documentation locally, run the following command from the root directory of the repository:</p> <p>With MkDocs:</p> <p>Additional requirements for building the docs are listed in <code>new_docs/requirements_docs.txt</code> and can be installed via:</p> <p><pre><code>pip install -r new_docs/requirements_docs.txt\n</code></pre> Then run:</p> <pre><code>mkdocs build   # Builds the documentation into the site/ directory\nmkdocs serve   # Serves the documentation locally\n</code></pre> <p>With Nox:</p> <pre><code>nox -s docs   # Builds the documentation into the site/ directory\nnox -s docs -- --fast   # Builds the documentation quickly without rendering code blocks (much faster building time)\nnox -s docs -- --serve (--fast)  # Serves the documentation locally\n</code></pre>"},{"location":"CONTRIBUTING_DOC/#style-specific-guide-generation","title":"Style-Specific Guide Generation","text":"<p>This directory contains an automated system for generating the documentation files with tabs for each experiment style from a template.</p>"},{"location":"CONTRIBUTING_DOC/#overview","title":"Overview","text":"<p>Instead of manually maintaining separate guide files for each experiment style or manually maintaining one file with all the tabs, we use a template-based approach:</p> <ol> <li>Template Files: <code>docs/*_template.md</code> contains the contents with tab placeholders ({{TABS_START}}/{{TABS_END}})</li> <li>Generation Script: <code>generate_style_guides.py</code> expands tabs with style-specific code for each experiment</li> <li>MkDocs Hook: <code>docs_hooks.py</code> automatically runs the script before each build</li> <li>Generated Files: <code>docs/*.md</code> without the <code>_template</code>, with tabs for CMS, ATLAS, LHCb, ALICE, DUNE, and plothist</li> </ol>"},{"location":"CONTRIBUTING_DOC/#files","title":"Files","text":"<ul> <li><code>docs/*_template.md</code> - Templates with <code>{{TABS_START}}/{{TABS_END}}</code> markers</li> <li><code>generate_style_guides.py</code> - Script to generate guide.md with experiment tabs</li> <li><code>docs_hooks.py</code> - MkDocs hook that runs the generation script automatically</li> </ul>"},{"location":"CONTRIBUTING_DOC/#how-it-works","title":"How It Works","text":""},{"location":"CONTRIBUTING_DOC/#template-structure","title":"Template Structure","text":"<p>The template uses special markers to denote tabbed sections:</p> <pre><code>{{TABS_START}}\n{{TAB_HEADER}}\n\n    ```python\n    # mkdocs: render\n    import mplhep as mh\n\n    mh.style.use('{{STYLE_CODE}}')\n    # ... code ...\n    {{LABEL_CODE}}\n{{MAGIC_CODE}}    ax.legend()\n    ```\n\n{{TABS_END}}\n</code></pre> <p>This generates tabs for all 6 styles (CMS, ATLAS, LHCb, ALICE, DUNE, plothist).</p>"},{"location":"CONTRIBUTING_DOC/#placeholders","title":"Placeholders","text":"<p>Within tabbed sections, these placeholders get replaced per style:</p> <ul> <li><code>{{STYLE_NAME}}</code> - Full style name (e.g., \"CMS\", \"ATLAS\")</li> <li><code>{{STYLE_CODE}}</code> - Style code for <code>mh.style.use()</code> (e.g., \"CMS\", \"LHCb2\")</li> <li><code>{{LABEL_CODE}}</code> - Label code with all parameters</li> <li><code>{{LABEL_CODE_NODATA}}</code> - Label code without data parameter</li> <li><code>{{LABEL_CODE_DATA}}</code> - Label code with data=True</li> <li><code>{{LABEL_CODE_AX}}</code> - Label code with ax parameter</li> <li><code>{{LABEL_CODE_LUMI}}</code> - Label code with luminosity</li> <li><code>{{MAGIC_CODE}}</code> - mpl_magic() call if needed (ATLAS, ALICE only)</li> </ul>"},{"location":"CONTRIBUTING_DOC/#generation-script","title":"Generation Script","text":"<p>Run manually: <pre><code># Generate guide.md with tabs\npython generate_style_guides.py\n\n# Custom paths\npython generate_style_guides.py --template my_template.md --output my_output/guide.md\n</code></pre></p>"},{"location":"CONTRIBUTING_DOC/#automatic-generation","title":"Automatic Generation","text":"<p>The MkDocs hook automatically runs the generation script before every build:</p> <p>With MkDocs:</p> <pre><code>mkdocs build   # Guide is generated automatically\nmkdocs serve   # Guide is generated on startup\n</code></pre> <p>With Nox:</p> <pre><code>nox -s docs   # Guide is generated automatically\nnox -s docs -- --serve   # Guide is generated on startup\n</code></pre>"},{"location":"CONTRIBUTING_DOC/#making-changes","title":"Making Changes","text":""},{"location":"CONTRIBUTING_DOC/#to-update-the-templates","title":"To update the templates:","text":"<ol> <li>Edit <code>docs/*_template.md</code></li> <li>For content that should be the same across all styles, edit it directly</li> <li>For content that varies by style, use <code>{{TABS_START}}</code> ... <code>{{TABS_END}}</code> markers</li> <li>Test generation: <code>python generate_style_guides.py</code></li> <li>Build docs via MkDocs or Nox to see changes</li> <li><code>docs/*.md</code> without the <code>_template</code> files will be regenerated automatically</li> </ol>"},{"location":"CONTRIBUTING_DOC/#to-add-a-new-style","title":"To add a new style:","text":"<ol> <li>Add style configuration to <code>generate_style_guides.py</code> in the <code>STYLES</code> dict</li> <li>Add the style name to <code>STYLE_ORDER</code> list</li> <li>Run the generation script</li> </ol>"},{"location":"CONTRIBUTING_DOC/#to-modify-style-specific-code","title":"To modify style-specific code:","text":"<ol> <li>Edit the appropriate entry in the <code>STYLES</code> dict in <code>generate_style_guides.py</code></li> <li>Regenerate: <code>python generate_style_guides.py</code></li> </ol>"},{"location":"CONTRIBUTING_DOC/#example-template-usage","title":"Example Template Usage","text":"<pre><code>#### Simple Example\n\nThis shows a basic histogram with different styles:\n\n{{TABS_START}}\n{{TAB_HEADER}}\n\n    ```python\n    # mkdocs: render\n    import mplhep as mh\n\n    mh.style.use('{{STYLE_CODE}}')\n    # Create plot\n    {{LABEL_CODE}}\n{{MAGIC_CODE}}    plt.show()\n    ```\n\n{{TABS_END}}\n</code></pre> <p>This generates:</p> <pre><code>=== \"CMS\"\n\n    ```python\n    # mkdocs: render\n    import mplhep as mh\n\n    mh.style.use('CMS')\n    # Create plot\n    mh.cms.label('Preliminary', data=True, lumi=100, com=13)\n    plt.show()\n    ```\n\n=== \"ATLAS\"\n\n    ```python\n    # mkdocs: render\n    import mplhep as mh\n\n    mh.style.use('ATLAS')\n    # Create plot\n    mh.atlas.label('Internal', data=True, lumi=150, com=13)\n    mh.mpl_magic(soft_fail=True)\n    plt.show()\n    ```\n\n...\n</code></pre>"},{"location":"CONTRIBUTING_DOC/#benefits","title":"Benefits","text":"<ol> <li>Single Source of Truth: Edit one template, update all style tabs</li> <li>Consistency: All style tabs have identical structure and examples</li> <li>Easy Maintenance: No need to manually sync changes across tabs</li> <li>Automatic: Integrated into the build process via MkDocs hook</li> <li>Flexible: Easy to add new styles or modify existing ones</li> <li>Clean: Template is much simpler than manually maintaining all tabs</li> </ol>"},{"location":"CONTRIBUTING_DOC/#troubleshooting","title":"Troubleshooting","text":""},{"location":"CONTRIBUTING_DOC/#guide-not-updating","title":"Guide not updating","text":"<p>Make sure you're editing <code>docs/*_template.md</code>.</p>"},{"location":"CONTRIBUTING_DOC/#build-errors","title":"Build errors","text":"<p>Check that all placeholders in the template are defined in the <code>STYLES</code> dict in <code>generate_style_guides.py</code>.</p>"},{"location":"CONTRIBUTING_DOC/#missing-mpl_magic-calls","title":"Missing mpl_magic calls","text":"<p>ATLAS and ALICE styles need <code>mh.mpl_magic(soft_fail=True)</code> after labels. This is handled automatically via the <code>MAGIC_CODE</code> placeholder which includes proper indentation.</p>"},{"location":"CONTRIBUTING_DOC/#testing-changes","title":"Testing changes","text":"<p>Always test locally before committing: <pre><code>python generate_style_guides.py\nmkdocs build / nox -s docs\n# Check the generated file\nless docs/guide.md\n</code></pre></p>"},{"location":"CONTRIBUTING_DOC/#manual-regeneration","title":"Manual regeneration","text":"<p>If the hook doesn't run for some reason: <pre><code>cd new_docs\npython generate_style_guides.py\n</code></pre></p>"},{"location":"api/","title":"API reference","text":"","boost":10},{"location":"api/#top-level","title":"Top Level","text":"","boost":10},{"location":"api/#mplhep","title":"mplhep","text":"<p>Primary namespace for mplhep. Holds primary plotting and most common functions.</p>","boost":10},{"location":"api/#mplhep.histplot","title":"mplhep.histplot","text":"<pre><code>histplot(H, bins=None, *, yerr: ArrayLike | bool | None = None, w2=None, w2method=None, stack: bool = False, density: bool = False, binwnorm=None, histtype: str = 'step', xerr=False, label=None, sort=None, edges=True, binticks=False, xoffsets=None, ax: Axes | None = None, flow='hint', blind=None, **kwargs)\n</code></pre> <p>Create a 1D histogram plot from <code>np.histogram</code>-like inputs.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>object</code> <p>Histogram object with containing values and optionally bins. Can be:</p> <ul> <li><code>np.histogram</code> tuple</li> <li>PlottableProtocol histogram object</li> <li><code>boost_histogram</code> classic (&lt;0.13) histogram object</li> <li>raw histogram values, provided <code>bins</code> is specified.</li> </ul> <p>Or list thereof.</p> required <code>bins</code> <code>iterable</code> <p>Histogram bins, if not part of <code>H</code>.</p> <code>None</code> <code>yerr</code> <code>iterable or bool</code> <p>Histogram uncertainties. Following modes are supported: - True, sqrt(N) errors or poissonian interval when <code>w2</code> is specified - shape(N) array of for one sided errors or list thereof - shape(Nx2) array of for two sided errors or list thereof</p> <code>None</code> <code>w2method</code> <code>callable</code> <p>Function calculating CLs with signature <code>low, high = fcn(w, w2)</code>. Here <code>low</code> and <code>high</code> are given in absolute terms, not relative to w. Default is <code>None</code>. If w2 has integer values (likely to be data) poisson interval is calculated, otherwise the resulting error is symmetric <code>sqrt(w2)</code>. Specifying <code>poisson</code> or <code>sqrt</code> will force that behaviours.</p> <code>None</code> <code>stack</code> <code>bool</code> <p>Whether to stack or overlay non-axis dimension (if it exists). N.B. in contrast to ROOT, stacking is performed in a single call aka <code>histplot([h1, h2, ...], stack=True)</code> as opposed to multiple calls.</p> <code>False</code> <code>density</code> <code>bool</code> <p>If true, convert sum weights to probability density (i.e. integrates to 1 over domain of axis) (Note: this option conflicts with <code>binwnorm</code>)</p> <code>False</code> <code>binwnorm</code> <code>float</code> <p>If true, convert sum weights to bin-width-normalized, with unit equal to     supplied value (usually you want to specify 1.)</p> <code>None</code> <code>histtype</code> <code>('step', 'fill', 'errorbar', 'bar', 'barstep', 'band')</code> <p>Type of histogram to plot:</p> <ul> <li>\"step\": skyline/step/outline of a histogram using plt.stairs.</li> <li>\"fill\": filled histogram using plt.stairs.</li> <li>\"errorbar\": single marker histogram using plt.errorbar.</li> <li>\"bar\": If multiple data are given the bars are arranged side by side using plt.bar. If only one histogram is provided, it will be treated as \"fill\" histtype.</li> <li>\"barstep\": If multiple data are given the steps are arranged side by side using plt.stairs. Supports yerr representation. If one histogram is provided, it will be treated as \"step\" histtype.</li> <li>\"band\": filled band spanning the yerr range of the histogram using plt.stairs.</li> </ul> <code>'step'</code> <code>label</code> <code>str or list</code> <p>Label for legend entry.</p> <code>None</code> <code>sort</code> <code>str, optional {'label'/'l', 'yield'/'y'}</code> <p>\"label\"/\"l\": sort histograms alphabetically by label, \"yield\"/\"y\": sort by total histogram yield. Append '_r' to reverse the order.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>flow</code> <code> str, optional { \"show\", \"sum\", \"hint\", \"none\"}</code> <p>Whether plot the under/overflow bin. If \"show\", add additional under/overflow bin. If \"sum\", add the under/overflow bin content to first/last bin. If \"hint\", draw markers at the axis to indicate presence of under/overflow. If \"none\", do nothing.</p> <code>'hint'</code> <code>blind</code> <code>int, tuple, str, slice, or list thereof</code> <p>Region(s) to blind (hide) in the histogram. Blinded bins are set to NaN, creating visual gaps. Supports:</p> <ul> <li><code>int</code>: single bin index to blind; a list of ints <code>[2, 5, 7]</code> blinds   those individual bins.</li> <li>Tuple <code>(lo, hi)</code>: value-based, blinds bins overlapping <code>[lo, hi)</code>.</li> <li>String <code>\"100j:200j\"</code>: <code>j</code> suffix for value-based; <code>\"3:7\"</code> for   index-based; <code>\"5:10j\"</code> for mixed (index start, value stop).</li> <li><code>mplhep.loc[lo:hi]</code>: value-based via the <code>mplhep.loc</code> helper.   <code>mplhep.loc[5:10j]</code> for mixed (index 5 start, value 10 stop).</li> <li><code>slice(100j, 200j)</code>: value-based via complex numbers (UHI convention).</li> <li><code>slice(3, 7)</code>: index-based.</li> <li><code>slice(3, 70j)</code>: mixed (index start, value stop).</li> <li>A list of any of the above to blind multiple regions.</li> </ul> <code>None</code> <code>**kwargs</code> <p>Keyword arguments passed to underlying matplotlib functions - {'stairs', 'errorbar'}.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>w2</code> <code>iterable</code> <p>Sum of the histogram weights squared for poissonian interval error calculation</p> <code>xerr</code> <code>bool or float</code> <p>Size of xerr if <code>histtype == 'errorbar'</code>. If <code>True</code>, bin-width will be used.</p> <code>edges</code> <code>bool</code> <p>Specifies whether to draw first and last edges of the histogram.</p> <code>binticks</code> <code>bool</code> <p>Attempts to draw x-axis ticks coinciding with bin boundaries if feasible.</p> <code>xoffsets</code> <code>bool</code> <p>If True, the bin \"centers\" of plotted histograms will be offset within their bin.</p> <p>Returns:</p> Type Description <code>List[Hist1DArtists]</code>","boost":10},{"location":"api/#mplhep.hist2dplot","title":"mplhep.hist2dplot","text":"<pre><code>hist2dplot(H, xbins=None, ybins=None, labels=None, labels_fontsize=None, labels_round=None, labels_color=None, cbar: bool = True, cbarsize='7%', cbarpad=0.2, cbarpos='right', cbarextend=None, cmin=None, cmax=None, mask=None, ax: Axes | None = None, flow='hint', binwnorm=None, **kwargs)\n</code></pre> <p>Create a 2D histogram plot from <code>np.histogram</code>-like inputs.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>object</code> <p>Histogram object with containing values and optionally bins. Can be:</p> <ul> <li><code>np.histogram</code> tuple</li> <li><code>boost_histogram</code> histogram object</li> <li>raw histogram values as list of list or 2d-array</li> </ul> required <code>xbins</code> <code>1D array-like</code> <p>Histogram bins along x axis, if not part of <code>H</code>.</p> <code>None</code> <code>ybins</code> <code>1D array-like</code> <p>Histogram bins along y axis, if not part of <code>H</code>.</p> <code>None</code> <code>labels</code> <code>2D array (H-like) or bool</code> <p>Array of per-bin labels to display. If <code>True</code> will display numerical values</p> <code>None, optional</code> <code>labels_fontsize</code> <code>float</code> <p>Fontsize of labels.</p> <code>None</code> <code>labels_color</code> <code>str</code> <p>Color of labels. If not given, will be decided automatically.</p> <code>None</code> <code>labels_round</code> <code>int</code> <p>Round labels to given number of decimals</p> <code>None</code> <code>cbar</code> <code>bool</code> <p>Draw a colorbar. In contrast to mpl behaviors the cbar axes is appended in such a way that it doesn't modify the original axes width:height ratio.</p> <code>True</code> <code>cbarsize</code> <code>str or float</code> <p>Colorbar width.</p> <code>\"7%\"</code> <code>cbarpad</code> <code>float</code> <p>Colorbar distance from main axis.</p> <code>0.2</code> <code>cbarpos</code> <code>('right', 'left', 'bottom', 'top')</code> <p>Colorbar position w.r.t main axis.</p> <code>'right'</code> <code>cbarextend</code> <code>bool</code> <p>Extends figure size to keep original axes size same as without cbar. If None (default), automatically set to True for single-axes figures and False for multi-axes figures to prevent layout issues.</p> <code>None (auto)</code> <code>cmin</code> <code>float</code> <p>Colorbar minimum.</p> <code>None</code> <code>cmax</code> <code>float</code> <p>Colorbar maximum.</p> <code>None</code> <code>mask</code> <code>2D array (H-like)</code> <p>Boolean mask to hide cells. Cells with False value are not shown.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>flow</code> <code> str, optional {\"show\", \"sum\",\"hint\", None}</code> <pre><code>Whether plot the under/overflow bin. If \"show\", add additional under/overflow bin. If \"sum\", add the under/overflow bin content to first/last bin. \"hint\" would highlight the bins with under/overflow contents\n</code></pre> <code>'hint'</code> <code>binwnorm</code> <code>float</code> <p>If true, convert sum weights to bin-width-normalized, with unit equal to     supplied value (usually you want to specify 1.)</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments passed to underlying matplotlib function - pcolormesh.</p> <code>{}</code> <p>Returns:</p> Type Description <code>    Hist2DArtist</code>","boost":10},{"location":"api/#mplhep.funcplot","title":"mplhep.funcplot","text":"<pre><code>funcplot(func, range, ax, stack=False, npoints=1000, **kwargs)\n</code></pre> <p>Plot a 1D function on a given range.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function or list of functions</code> <p>The 1D function or list of functions to plot. The function(s) should support vectorization (i.e. accept a numpy array as input).</p> required <code>range</code> <code>tuple</code> <p>The range of the function(s). The function(s) will be plotted on the interval [range[0], range[1]].</p> required <code>ax</code> <code>Axes</code> <p>The Axes instance for plotting.</p> required <code>stack</code> <code>bool</code> <p>Whether to use ax.stackplot() to plot the function(s) as a stacked plot. Default is False.</p> <code>False</code> <code>npoints</code> <code>int</code> <p>The number of points to use for plotting. Default is 1000.</p> <code>1000</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to ax.plot() (in case stack=False) or ax.stackplot() (in case stack=True).</p> <code>{}</code>","boost":10},{"location":"api/#mplhep.hist","title":"mplhep.hist","text":"<pre><code>hist(x, bins=10, *, range=None, density=False, weights=None, yerr: ArrayLike | bool | None = True, histtype: str = 'step', label=None, ax: Axes | None = None, **kwargs)\n</code></pre> <p>Create histogram from unbinned data, matching <code>plt.hist</code> API but using <code>histplot</code>.</p> <p>This function provides a convenient way to histogram raw data values while benefiting from the extended features of <code>histplot</code>, such as automatic error bar calculation, bin-width normalization, and HEP-style plotting options.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array-like or list of array-like</code> <p>Input values to histogram. Can be a single array or a list of arrays for multiple histograms.</p> required <code>bins</code> <code>int or sequence</code> <p>Number of bins or bin edges. If an integer, defines the number of equal-width bins in the range. If a sequence, defines the bin edges.</p> <code>10</code> <code>range</code> <code>tuple</code> <p>The lower and upper range of the bins as (min, max). If not provided, range is (x.min(), x.max()). Values outside the range are ignored.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, normalize histogram to form a probability density.</p> <code>False</code> <code>weights</code> <code>array - like</code> <p>Array of weights, of the same shape as <code>x</code>. Each value in <code>x</code> contributes its associated weight towards the bin count.</p> <code>None</code> <code>yerr</code> <code>array - like or bool</code> <p>Histogram uncertainties. If True (default), sqrt(N) errors or poissonian interval when weights are specified. Can also be an array of errors.</p> <code>True</code> <code>histtype</code> <code>('step', 'fill', 'errorbar', 'band')</code> <p>Type of histogram to plot (see <code>histplot</code> for details).</p> <code>'step'</code> <code>label</code> <code>str or list of str</code> <p>Label(s) for legend entry.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object to plot on. If None, uses current axes.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>histplot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Hist1DArtists]</code> <p>Artists created by histplot.</p> See Also <p>histplot : Plot pre-binned histograms matplotlib.pyplot.hist : Matplotlib histogram function</p>","boost":10},{"location":"api/#mplhep.add_text","title":"mplhep.add_text","text":"<pre><code>add_text(text: str, loc: str | None = None, x: float | str | None = None, y: float | str | None = None, pad: float | None = None, xpad: float | None = None, ypad: float | None = None, fontsize: float | None = None, white_background: bool = False, text_class: type[Text] = mtext.Text, ax: Axes | None = None, **kwargs: Any) -&gt; mtext.Text\n</code></pre> <p>Add text to an axis with flexible positioning options.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add to the axes.</p> required <code>loc</code> <code>str | None</code> <p>Location shortcut similar to plt.legend(). Can be:</p> <ul> <li>Inside axes: \"upper left\", \"upper right\", \"lower left\", \"lower right\"</li> <li>Outside axes: \"over left\", \"over right\", \"under left\", \"under right\"</li> <li>Alternative spellings: \"top left\", \"top right\", \"bottom left\", \"bottom right\"</li> </ul> <p>If provided, overrides x and y parameters.</p> <code>None</code> <code>x</code> <code>float | str | None</code> <p>Horizontal position of the text in normalized axes coordinates (0-1). String aliases: \"left\", \"right\", \"left_in\", \"right_in\", \"right_out\". Ignored if loc is provided.</p> <code>None</code> <code>y</code> <code>float | str | None</code> <p>Vertical position of the text in normalized axes coordinates (0-1). String aliases: \"top\", \"bottom\", \"top_in\", \"bottom_in\", \"top_out\", \"bottom_out\". Ignored if loc is provided.</p> <code>None</code> <code>pad</code> <code>float | None</code> <p>Padding percentage from edges for \"in\" positions, by default 5.0. Applied to the shorter dimension and scaled proportionally for the longer dimension.</p> <code>None</code> <code>xpad</code> <code>float | None</code> <p>Horizontal padding percentage, overrides pad value for x-direction if provided.</p> <code>None</code> <code>ypad</code> <code>float | None</code> <p>Vertical padding percentage, overrides pad value for y-direction if provided.</p> <code>None</code> <code>fontsize</code> <code>int | float | None</code> <p>Font size, by default None (uses rcParams default).</p> <code>None</code> <code>white_background</code> <code>bool</code> <p>Draw a white rectangle under the text, by default False.</p> <code>False</code> <code>text_class</code> <code>type[Text]</code> <p>Text class to use for creating the text object, by default mtext.Text.</p> <code>Text</code> <code>ax</code> <code>Axes | None</code> <p>Axes object to add text to. If None, uses current axes.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the text constructor. Notably 'ha' (horizontal alignment) and 'va' (vertical alignment) are set automatically based on position but can be overridden.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both loc and x/y parameters are specified, or if x/y positions are not valid floats or recognized string aliases.</p> <p>Returns:</p> Type Description <code>Text</code> <p>The text object that was added to the axes.</p>","boost":10},{"location":"api/#mplhep.append_text","title":"mplhep.append_text","text":"<pre><code>append_text(s: str, txt_obj: Text, loc: str = 'right', pad: str | float = 'auto', ax: Axes | None = None, text_class: type[Text] = mtext.Text, _debug_x_override: float | None = None, **kwargs: Any) -&gt; mtext.Text\n</code></pre> <p>Append text relative to an existing text object.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The text string to append.</p> required <code>txt_obj</code> <code>Text</code> <p>The existing text object to append to.</p> required <code>loc</code> <code>str</code> <p>Location relative to the existing text. Options are \"right\", \"below\", \"above\", or \"left\".</p> <code>\"right\"</code> <code>pad</code> <code>str | float</code> <p>Padding between texts. If \"auto\", uses automatic spacing. If float, specifies padding as percentage of axes size.</p> <code>\"auto\"</code> <code>ax</code> <code>Axes | None</code> <p>Axes object. If None, uses current axes.</p> <code>None</code> <code>text_class</code> <code>type[Text]</code> <p>Text class to use for creating the new text object.</p> <code>Text</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the text constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Text</code> <p>The appended text object.</p>","boost":10},{"location":"api/#plotting","title":"Plotting","text":"","boost":10},{"location":"api/#mplhep.plot","title":"mplhep.plot","text":"","boost":10},{"location":"api/#mplhep.plot.histplot","title":"mplhep.plot.histplot","text":"<pre><code>histplot(H, bins=None, *, yerr: ArrayLike | bool | None = None, w2=None, w2method=None, stack: bool = False, density: bool = False, binwnorm=None, histtype: str = 'step', xerr=False, label=None, sort=None, edges=True, binticks=False, xoffsets=None, ax: Axes | None = None, flow='hint', blind=None, **kwargs)\n</code></pre> <p>Create a 1D histogram plot from <code>np.histogram</code>-like inputs.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>object</code> <p>Histogram object with containing values and optionally bins. Can be:</p> <ul> <li><code>np.histogram</code> tuple</li> <li>PlottableProtocol histogram object</li> <li><code>boost_histogram</code> classic (&lt;0.13) histogram object</li> <li>raw histogram values, provided <code>bins</code> is specified.</li> </ul> <p>Or list thereof.</p> required <code>bins</code> <code>iterable</code> <p>Histogram bins, if not part of <code>H</code>.</p> <code>None</code> <code>yerr</code> <code>iterable or bool</code> <p>Histogram uncertainties. Following modes are supported: - True, sqrt(N) errors or poissonian interval when <code>w2</code> is specified - shape(N) array of for one sided errors or list thereof - shape(Nx2) array of for two sided errors or list thereof</p> <code>None</code> <code>w2method</code> <code>callable</code> <p>Function calculating CLs with signature <code>low, high = fcn(w, w2)</code>. Here <code>low</code> and <code>high</code> are given in absolute terms, not relative to w. Default is <code>None</code>. If w2 has integer values (likely to be data) poisson interval is calculated, otherwise the resulting error is symmetric <code>sqrt(w2)</code>. Specifying <code>poisson</code> or <code>sqrt</code> will force that behaviours.</p> <code>None</code> <code>stack</code> <code>bool</code> <p>Whether to stack or overlay non-axis dimension (if it exists). N.B. in contrast to ROOT, stacking is performed in a single call aka <code>histplot([h1, h2, ...], stack=True)</code> as opposed to multiple calls.</p> <code>False</code> <code>density</code> <code>bool</code> <p>If true, convert sum weights to probability density (i.e. integrates to 1 over domain of axis) (Note: this option conflicts with <code>binwnorm</code>)</p> <code>False</code> <code>binwnorm</code> <code>float</code> <p>If true, convert sum weights to bin-width-normalized, with unit equal to     supplied value (usually you want to specify 1.)</p> <code>None</code> <code>histtype</code> <code>('step', 'fill', 'errorbar', 'bar', 'barstep', 'band')</code> <p>Type of histogram to plot:</p> <ul> <li>\"step\": skyline/step/outline of a histogram using plt.stairs.</li> <li>\"fill\": filled histogram using plt.stairs.</li> <li>\"errorbar\": single marker histogram using plt.errorbar.</li> <li>\"bar\": If multiple data are given the bars are arranged side by side using plt.bar. If only one histogram is provided, it will be treated as \"fill\" histtype.</li> <li>\"barstep\": If multiple data are given the steps are arranged side by side using plt.stairs. Supports yerr representation. If one histogram is provided, it will be treated as \"step\" histtype.</li> <li>\"band\": filled band spanning the yerr range of the histogram using plt.stairs.</li> </ul> <code>'step'</code> <code>label</code> <code>str or list</code> <p>Label for legend entry.</p> <code>None</code> <code>sort</code> <code>str, optional {'label'/'l', 'yield'/'y'}</code> <p>\"label\"/\"l\": sort histograms alphabetically by label, \"yield\"/\"y\": sort by total histogram yield. Append '_r' to reverse the order.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>flow</code> <code> str, optional { \"show\", \"sum\", \"hint\", \"none\"}</code> <p>Whether plot the under/overflow bin. If \"show\", add additional under/overflow bin. If \"sum\", add the under/overflow bin content to first/last bin. If \"hint\", draw markers at the axis to indicate presence of under/overflow. If \"none\", do nothing.</p> <code>'hint'</code> <code>blind</code> <code>int, tuple, str, slice, or list thereof</code> <p>Region(s) to blind (hide) in the histogram. Blinded bins are set to NaN, creating visual gaps. Supports:</p> <ul> <li><code>int</code>: single bin index to blind; a list of ints <code>[2, 5, 7]</code> blinds   those individual bins.</li> <li>Tuple <code>(lo, hi)</code>: value-based, blinds bins overlapping <code>[lo, hi)</code>.</li> <li>String <code>\"100j:200j\"</code>: <code>j</code> suffix for value-based; <code>\"3:7\"</code> for   index-based; <code>\"5:10j\"</code> for mixed (index start, value stop).</li> <li><code>mplhep.loc[lo:hi]</code>: value-based via the <code>mplhep.loc</code> helper.   <code>mplhep.loc[5:10j]</code> for mixed (index 5 start, value 10 stop).</li> <li><code>slice(100j, 200j)</code>: value-based via complex numbers (UHI convention).</li> <li><code>slice(3, 7)</code>: index-based.</li> <li><code>slice(3, 70j)</code>: mixed (index start, value stop).</li> <li>A list of any of the above to blind multiple regions.</li> </ul> <code>None</code> <code>**kwargs</code> <p>Keyword arguments passed to underlying matplotlib functions - {'stairs', 'errorbar'}.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>w2</code> <code>iterable</code> <p>Sum of the histogram weights squared for poissonian interval error calculation</p> <code>xerr</code> <code>bool or float</code> <p>Size of xerr if <code>histtype == 'errorbar'</code>. If <code>True</code>, bin-width will be used.</p> <code>edges</code> <code>bool</code> <p>Specifies whether to draw first and last edges of the histogram.</p> <code>binticks</code> <code>bool</code> <p>Attempts to draw x-axis ticks coinciding with bin boundaries if feasible.</p> <code>xoffsets</code> <code>bool</code> <p>If True, the bin \"centers\" of plotted histograms will be offset within their bin.</p> <p>Returns:</p> Type Description <code>List[Hist1DArtists]</code>","boost":10},{"location":"api/#mplhep.plot.hist2dplot","title":"mplhep.plot.hist2dplot","text":"<pre><code>hist2dplot(H, xbins=None, ybins=None, labels=None, labels_fontsize=None, labels_round=None, labels_color=None, cbar: bool = True, cbarsize='7%', cbarpad=0.2, cbarpos='right', cbarextend=None, cmin=None, cmax=None, mask=None, ax: Axes | None = None, flow='hint', binwnorm=None, **kwargs)\n</code></pre> <p>Create a 2D histogram plot from <code>np.histogram</code>-like inputs.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>object</code> <p>Histogram object with containing values and optionally bins. Can be:</p> <ul> <li><code>np.histogram</code> tuple</li> <li><code>boost_histogram</code> histogram object</li> <li>raw histogram values as list of list or 2d-array</li> </ul> required <code>xbins</code> <code>1D array-like</code> <p>Histogram bins along x axis, if not part of <code>H</code>.</p> <code>None</code> <code>ybins</code> <code>1D array-like</code> <p>Histogram bins along y axis, if not part of <code>H</code>.</p> <code>None</code> <code>labels</code> <code>2D array (H-like) or bool</code> <p>Array of per-bin labels to display. If <code>True</code> will display numerical values</p> <code>None, optional</code> <code>labels_fontsize</code> <code>float</code> <p>Fontsize of labels.</p> <code>None</code> <code>labels_color</code> <code>str</code> <p>Color of labels. If not given, will be decided automatically.</p> <code>None</code> <code>labels_round</code> <code>int</code> <p>Round labels to given number of decimals</p> <code>None</code> <code>cbar</code> <code>bool</code> <p>Draw a colorbar. In contrast to mpl behaviors the cbar axes is appended in such a way that it doesn't modify the original axes width:height ratio.</p> <code>True</code> <code>cbarsize</code> <code>str or float</code> <p>Colorbar width.</p> <code>\"7%\"</code> <code>cbarpad</code> <code>float</code> <p>Colorbar distance from main axis.</p> <code>0.2</code> <code>cbarpos</code> <code>('right', 'left', 'bottom', 'top')</code> <p>Colorbar position w.r.t main axis.</p> <code>'right'</code> <code>cbarextend</code> <code>bool</code> <p>Extends figure size to keep original axes size same as without cbar. If None (default), automatically set to True for single-axes figures and False for multi-axes figures to prevent layout issues.</p> <code>None (auto)</code> <code>cmin</code> <code>float</code> <p>Colorbar minimum.</p> <code>None</code> <code>cmax</code> <code>float</code> <p>Colorbar maximum.</p> <code>None</code> <code>mask</code> <code>2D array (H-like)</code> <p>Boolean mask to hide cells. Cells with False value are not shown.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>flow</code> <code> str, optional {\"show\", \"sum\",\"hint\", None}</code> <pre><code>Whether plot the under/overflow bin. If \"show\", add additional under/overflow bin. If \"sum\", add the under/overflow bin content to first/last bin. \"hint\" would highlight the bins with under/overflow contents\n</code></pre> <code>'hint'</code> <code>binwnorm</code> <code>float</code> <p>If true, convert sum weights to bin-width-normalized, with unit equal to     supplied value (usually you want to specify 1.)</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments passed to underlying matplotlib function - pcolormesh.</p> <code>{}</code> <p>Returns:</p> Type Description <code>    Hist2DArtist</code>","boost":10},{"location":"api/#mplhep.plot.model","title":"mplhep.plot.model","text":"<pre><code>model(stacked_components=None, stacked_labels=None, stacked_colors=None, unstacked_components=None, unstacked_labels=None, unstacked_colors=None, xlabel=None, ylabel=None, stacked_kwargs=None, unstacked_kwargs_list=None, model_sum_kwargs=None, function_range=None, model_uncertainty=True, model_uncertainty_label='MC stat. unc.', fig=None, ax=None, flow='hint', blind=None)\n</code></pre> <p>Plot model made of a collection of histograms.</p> <p>Parameters:</p> Name Type Description Default <code>stacked_components</code> <code>list of histogram (e.g. Hist, boost_histogram, np.histogram, TH1)</code> <p>The list of histograms to be stacked composing the model. Default is None.</p> <code>None</code> <code>stacked_labels</code> <code>list of str</code> <p>The labels of the model stacked components. Default is None.</p> <code>None</code> <code>stacked_colors</code> <code>list of str</code> <p>The colors of the model stacked components. Default is None.</p> <code>None</code> <code>unstacked_components</code> <code>list of histogram (e.g. Hist, boost_histogram, np.histogram, TH1)</code> <p>The list of histograms not to be stacked composing the model. Default is None.</p> <code>None</code> <code>unstacked_labels</code> <code>list of str</code> <p>The labels of the model unstacked components. Default is None.</p> <code>None</code> <code>unstacked_colors</code> <code>list of str</code> <p>The colors of the model unstacked components. Default is None.</p> <code>None</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis. Default is None.</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis. Default is None.</p> <code>None</code> <code>stacked_kwargs</code> <code>dict</code> <p>The keyword arguments used when plotting the stacked components in plot_hist() or plot_function(), one of which is called only once. Default is None.</p> <code>None</code> <code>unstacked_kwargs_list</code> <code>list of dict</code> <p>The list of keyword arguments used when plotting the unstacked components in plot_hist() or plot_function(), one of which is called once for each unstacked component. Default is None.</p> <code>None</code> <code>model_sum_kwargs</code> <code>dict</code> <p>The keyword arguments for the plot_hist() function for the sum of the model components. Has no effect if all the model components are stacked or if the model is one unstacked element. The special keyword \"show\" can be used with a boolean to specify whether to show or not the sum of the model components. Default is None. If None is provided, this is set to {\"show\": True, \"label\": \"Model\", \"color\": \"navy\"}.</p> <code>None</code> <code>function_range</code> <code>tuple, optional (mandatory if the model is made of functions)</code> <p>The range for the x-axis if the model is made of functions.</p> <code>None</code> <code>model_uncertainty</code> <code>bool</code> <p>If False, set the model uncertainties to zeros. Default is True.</p> <code>True</code> <code>model_uncertainty_label</code> <code>str</code> <p>The label for the model uncertainties. Default is \"MC stat. unc.\".</p> <code>'MC stat. unc.'</code> <code>fig</code> <code>Figure or None</code> <p>The Figure object to use for the plot. Create a new one if none is provided.</p> <code>None</code> <code>ax</code> <code>Axes or None</code> <p>The Axes object to use for the plot. Create a new one if none is provided.</p> <code>None</code> <code>flow</code> <code>str</code> <p>Whether to show under/overflow bins. Options: \"show\", \"sum\", \"hint\", \"none\". Default is \"hint\".</p> <code>'hint'</code> <code>blind</code> <code>int, tuple, str, slice, or list thereof</code> <p>Region(s) to blind (including individual bin indices). Passed through to <code>histplot</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The Figure object containing the plot.</p> <code>ax</code> <code>Axes</code> <p>The Axes object containing the plot.</p>","boost":10},{"location":"api/#mplhep.plot.funcplot","title":"mplhep.plot.funcplot","text":"<pre><code>funcplot(func, range, ax, stack=False, npoints=1000, **kwargs)\n</code></pre> <p>Plot a 1D function on a given range.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function or list of functions</code> <p>The 1D function or list of functions to plot. The function(s) should support vectorization (i.e. accept a numpy array as input).</p> required <code>range</code> <code>tuple</code> <p>The range of the function(s). The function(s) will be plotted on the interval [range[0], range[1]].</p> required <code>ax</code> <code>Axes</code> <p>The Axes instance for plotting.</p> required <code>stack</code> <code>bool</code> <p>Whether to use ax.stackplot() to plot the function(s) as a stacked plot. Default is False.</p> <code>False</code> <code>npoints</code> <code>int</code> <p>The number of points to use for plotting. Default is 1000.</p> <code>1000</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to ax.plot() (in case stack=False) or ax.stackplot() (in case stack=True).</p> <code>{}</code>","boost":10},{"location":"api/#mplhep.plot.hist","title":"mplhep.plot.hist","text":"<pre><code>hist(x, bins=10, *, range=None, density=False, weights=None, yerr: ArrayLike | bool | None = True, histtype: str = 'step', label=None, ax: Axes | None = None, **kwargs)\n</code></pre> <p>Create histogram from unbinned data, matching <code>plt.hist</code> API but using <code>histplot</code>.</p> <p>This function provides a convenient way to histogram raw data values while benefiting from the extended features of <code>histplot</code>, such as automatic error bar calculation, bin-width normalization, and HEP-style plotting options.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array-like or list of array-like</code> <p>Input values to histogram. Can be a single array or a list of arrays for multiple histograms.</p> required <code>bins</code> <code>int or sequence</code> <p>Number of bins or bin edges. If an integer, defines the number of equal-width bins in the range. If a sequence, defines the bin edges.</p> <code>10</code> <code>range</code> <code>tuple</code> <p>The lower and upper range of the bins as (min, max). If not provided, range is (x.min(), x.max()). Values outside the range are ignored.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, normalize histogram to form a probability density.</p> <code>False</code> <code>weights</code> <code>array - like</code> <p>Array of weights, of the same shape as <code>x</code>. Each value in <code>x</code> contributes its associated weight towards the bin count.</p> <code>None</code> <code>yerr</code> <code>array - like or bool</code> <p>Histogram uncertainties. If True (default), sqrt(N) errors or poissonian interval when weights are specified. Can also be an array of errors.</p> <code>True</code> <code>histtype</code> <code>('step', 'fill', 'errorbar', 'band')</code> <p>Type of histogram to plot (see <code>histplot</code> for details).</p> <code>'step'</code> <code>label</code> <code>str or list of str</code> <p>Label(s) for legend entry.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object to plot on. If None, uses current axes.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>histplot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Hist1DArtists]</code> <p>Artists created by histplot.</p> See Also <p>histplot : Plot pre-binned histograms matplotlib.pyplot.hist : Matplotlib histogram function</p>","boost":10},{"location":"api/#mplhep.comp","title":"mplhep.comp","text":"<p>Comparison/compound plotting module.</p> <p>This module provides functions to create comparison plots, such as ratio plots, data vs. model comparisons, and more.</p>","boost":10},{"location":"api/#mplhep.comp.comparison","title":"mplhep.comp.comparison","text":"<pre><code>comparison(h1, h2, ax, xlabel='', h1_label='h1', h2_label='h2', comparison='ratio', comparison_ylabel=None, comparison_ylim=None, h1_w2method='sqrt', flow='hint', blind=None, **histplot_kwargs)\n</code></pre> <p>Plot the comparison between two histograms.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram for comparison.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram for comparison.</p> required <code>ax</code> <code>Axes</code> <p>The axes to plot the comparison.</p> required <code>xlabel</code> <code>str</code> <p>The label for the x-axis. Default is \"\".</p> <code>''</code> <code>h1_label</code> <code>str</code> <p>The label for the first histogram. Default is \"h1\".</p> <code>'h1'</code> <code>h2_label</code> <code>str</code> <p>The label for the second histogram. Default is \"h2\".</p> <code>'h2'</code> <code>comparison</code> <code>str</code> <p>The type of comparison to plot (\"ratio\", \"split_ratio\", \"pull\", \"difference\", \"relative_difference\", \"efficiency\", or \"asymmetry\"). Default is \"ratio\". When the <code>split_ratio</code> option is used, both the h1 and h2 uncertainties are scaled down by the h2 bin contents, and the h2 adjusted uncertainties are shown separately as a hatched area.</p> <code>'ratio'</code> <code>comparison_ylabel</code> <code>str</code> <p>The label for the y-axis. Default is the explicit formula used to compute the comparison plot.</p> <code>None</code> <code>comparison_ylim</code> <code>tuple or None</code> <p>The y-axis limits for the comparison plot. Default is None. If None, standard y-axis limits are setup.</p> <code>None</code> <code>h1_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for h1: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"sqrt\". Asymmetrical uncertainties are not supported for the asymmetry and efficiency comparisons.</p> <code>'sqrt'</code> <code>flow</code> <code>str</code> <p>Whether to show under/overflow bins. Options: \"show\", \"sum\", \"hint\", \"none\". Default is \"hint\".</p> <code>'hint'</code> <code>**histplot_kwargs</code> <code>optional</code> <p>Arguments to be passed to histplot(), called in case the comparison is \"pull\", or plot_error_hist(), called for every other comparison case. In the former case, the default arguments are histtype=\"stepfilled\" and color=\"darkgrey\". In the later case, the default argument is color=\"black\".</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code> <p>The axes with the plotted comparison.</p> See Also <p>hists : Compare two histograms and plot the comparison.</p>","boost":10},{"location":"api/#mplhep.comp.data_model","title":"mplhep.comp.data_model","text":"<pre><code>data_model(data_hist, stacked_components=None, stacked_labels=None, stacked_colors=None, unstacked_components=None, unstacked_labels=None, unstacked_colors=None, xlabel=None, ylabel=None, data_label='Data', stacked_kwargs=None, unstacked_kwargs_list=None, model_sum_kwargs=None, model_uncertainty=True, model_uncertainty_label='MC stat. unc.', data_w2method='poisson', fig=None, ax_main=None, ax_comparison=None, plot_only=None, flow='hint', blind=None, **comparison_kwargs)\n</code></pre> <p>Compare data to model. The data uncertainties are computed using the Poisson confidence interval.</p> <p>Parameters:</p> Name Type Description Default <code>data_hist</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The histogram for the data.</p> required <code>stacked_components</code> <code>list of histogram (e.g. Hist, boost_histogram, np.histogram, TH1)</code> <p>The list of histograms to be stacked composing the model. Default is None.</p> <code>None</code> <code>stacked_labels</code> <code>list of str</code> <p>The labels of the model stacked components. Default is None.</p> <code>None</code> <code>stacked_colors</code> <code>list of str</code> <p>The colors of the model stacked components. Default is None.</p> <code>None</code> <code>unstacked_components</code> <code>list of histogram (e.g. Hist, boost_histogram, np.histogram, TH1)</code> <p>The list of histograms not to be stacked composing the model. Default is None.</p> <code>None</code> <code>unstacked_labels</code> <code>list of str</code> <p>The labels of the model unstacked components. Default is None.</p> <code>None</code> <code>unstacked_colors</code> <code>list of str</code> <p>The colors of the model unstacked components. Default is None.</p> <code>None</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis. Default is None.</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis. Default is None.</p> <code>None</code> <code>data_label</code> <code>str</code> <p>The label for the data. Default is \"Data\".</p> <code>'Data'</code> <code>stacked_kwargs</code> <code>dict</code> <p>The keyword arguments used when plotting the stacked components in plot_hist() or plot_function(), one of which is called only once. Default is None.</p> <code>None</code> <code>unstacked_kwargs_list</code> <code>list of dict</code> <p>The list of keyword arguments used when plotting the unstacked components in plot_hist() or plot_function(), one of which is called once for each unstacked component. Default is None.</p> <code>None</code> <code>model_sum_kwargs</code> <code>dict</code> <p>The keyword arguments for the plot_hist() function for the sum of the model components. Has no effect if all the model components are stacked or if the model is one unstacked element. The special keyword \"show\" can be used with a boolean to specify whether to show or not the sum of the model components. Default is None. If None is provided, this is set to {\"show\": True, \"label\": \"Sum\", \"color\": \"navy\"}.</p> <code>None</code> <code>model_uncertainty</code> <code>bool</code> <p>If False, set the model uncertainties to zeros. Default is True.</p> <code>True</code> <code>model_uncertainty_label</code> <code>str</code> <p>The label for the model uncertainties. Default is \"MC stat. unc.\".</p> <code>'MC stat. unc.'</code> <code>data_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for data_hist: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"poisson\".</p> <code>'poisson'</code> <code>fig</code> <code>Figure or None</code> <p>The figure to use for the plot. If fig, ax_main and ax_comparison are None, a new figure will be created. Default is None.</p> <code>None</code> <code>ax_main</code> <code>Axes or None</code> <p>The main axes for the histogram comparison. If fig, ax_main and ax_comparison are None, a new axes will be created. Default is None.</p> <code>None</code> <code>ax_comparison</code> <code>Axes or None</code> <p>The axes for the comparison plot. If fig, ax_main and ax_comparison are None, a new axes will be created. Default is None.</p> <code>None</code> <code>plot_only</code> <code>str</code> <p>If \"ax_main\" or \"ax_comparison\", only the main or comparison axis is plotted on the figure. Both axes are plotted if None is specified, which is the default. This can only be used when fig, ax_main and ax_comparison are not provided by the user.</p> <code>None</code> <code>flow</code> <code>str</code> <p>Whether to show under/overflow bins. Options: \"show\", \"sum\", \"hint\", \"none\". Default is \"hint\".</p> <code>'hint'</code> <code>**comparison_kwargs</code> <code>optional</code> <p>Arguments to be passed to comparison(), including the choice of the comparison function and the treatment of the uncertainties (see documentation of comparison() for details). If they are not provided explicitly, the following arguments are passed by default: h1_label=\"Data\", h2_label=\"MC\", comparison=\"split_ratio\".</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The Figure object containing the plots.</p> <code>ax_main</code> <code>Axes</code> <p>The Axes object for the main plot.</p> <code>ax_comparison</code> <code>Axes</code> <p>The Axes object for the comparison plot.</p> See Also <p>comparison : Plot the comparison between two histograms.</p>","boost":10},{"location":"api/#mplhep.comp.hists","title":"mplhep.comp.hists","text":"<pre><code>hists(h1, h2, xlabel=None, ylabel=None, h1_label='h1', h2_label='h2', fig=None, ax_main=None, ax_comparison=None, flow='hint', blind=None, **comparison_kwargs)\n</code></pre> <p>Compare two histograms.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram to compare.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram to compare.</p> required <code>xlabel</code> <code>str</code> <p>The label for the x-axis. Default is None.</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis. Default is None.</p> <code>None</code> <code>h1_label</code> <code>str</code> <p>The label for the first histogram. Default is \"h1\".</p> <code>'h1'</code> <code>h2_label</code> <code>str</code> <p>The label for the second histogram. Default is \"h2\".</p> <code>'h2'</code> <code>fig</code> <code>Figure or None</code> <p>The figure to use for the plot. If fig, ax_main and ax_comparison are None, a new figure will be created. Default is None.</p> <code>None</code> <code>ax_main</code> <code>Axes or None</code> <p>The main axes for the histogram comparison. If fig, ax_main and ax_comparison are None, a new axes will be created. Default is None.</p> <code>None</code> <code>ax_comparison</code> <code>Axes or None</code> <p>The axes for the comparison plot. If fig, ax_main and ax_comparison are None, a new axes will be created. Default is None.</p> <code>None</code> <code>flow</code> <code>str</code> <p>Whether to show under/overflow bins. Options: \"show\", \"sum\", \"hint\", \"none\". Default is \"hint\".</p> <code>'hint'</code> <code>**comparison_kwargs</code> <code>optional</code> <p>Arguments to be passed to comparison(), including the choice of the comparison function and the treatment of the uncertainties (see documentation of comparison() for details).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The created figure.</p> <code>ax_main</code> <code>Axes</code> <p>The main axes for the histogram comparison.</p> <code>ax_comparison</code> <code>Axes</code> <p>The axes for the comparison plot.</p> See Also <p>comparison : Plot the comparison between two histograms.</p>","boost":10},{"location":"api/#mplhep.comp.get_asymmetry","title":"mplhep.comp.get_asymmetry","text":"<pre><code>get_asymmetry(h1, h2)\n</code></pre> <p>Get the asymmetry between two histograms h1 and h2, defined as (h1 - h2) / (h1 + h2). Only symmetrical uncertainties are supported.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram.</p> required <p>Returns:</p> Name Type Description <code>asymmetry_values</code> <code>ndarray</code> <p>The asymmetry values.</p> <code>asymmetry_uncertainties</code> <code>ndarray</code> <p>The uncertainties on the asymmetry.</p>","boost":10},{"location":"api/#mplhep.comp.get_comparison","title":"mplhep.comp.get_comparison","text":"<pre><code>get_comparison(h1, h2, comparison, h1_w2method='sqrt')\n</code></pre> <p>Compute the comparison between two histograms.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram for comparison.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram for comparison.</p> required <code>comparison</code> <code>str</code> <p>The type of comparison (\"ratio\", \"split_ratio\", \"pull\", \"difference\", \"relative_difference\", \"efficiency\", or \"asymmetry\"). When the <code>split_ratio</code> option is used, the uncertainties of h1 are scaled down by the bin contents of h2, i.e. assuming zero uncertainty coming from h2 in the ratio uncertainty.</p> required <code>h1_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for h1: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"sqrt\". Asymmetrical uncertainties are not supported for the asymmetry and efficiency comparisons.</p> <code>'sqrt'</code> <p>Returns:</p> Name Type Description <code>values</code> <code>ndarray</code> <p>The comparison values.</p> <code>lower_uncertainties</code> <code>ndarray</code> <p>The lower uncertainties on the comparison values.</p> <code>upper_uncertainties</code> <code>ndarray</code> <p>The upper uncertainties on the comparison values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the comparison is not valid.</p> <code>ValueError</code> <p>If h1_w2method is not one of [\"sqrt\", \"poisson\"].</p> <code>ValueError</code> <p>If the h1_w2method is \"poisson\" and the comparison is \"asymmetry\" or \"efficiency\".</p>","boost":10},{"location":"api/#mplhep.comp.get_difference","title":"mplhep.comp.get_difference","text":"<pre><code>get_difference(h1, h2, h1_w2method='sqrt')\n</code></pre> <p>Compute the difference between two histograms.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> required <code>h1_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for h1: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"sqrt\".</p> <code>'sqrt'</code> <p>Returns:</p> Name Type Description <code>difference_values</code> <code>ndarray</code> <p>The difference values.</p> <code>difference_uncertainties_low</code> <code>ndarray</code> <p>The lower uncertainties on the difference.</p> <code>difference_uncertainties_high</code> <code>ndarray</code> <p>The upper uncertainties on the difference.</p>","boost":10},{"location":"api/#mplhep.comp.get_efficiency","title":"mplhep.comp.get_efficiency","text":"<pre><code>get_efficiency(h1, h2)\n</code></pre> <p>Calculate the ratio of two correlated histograms (h1/h2), in which the entries of h1 are a subsample of the entries of h2. The variances are calculated using the Bayesian method with a uniform prior Beta(1,1), following the approach in ROOT's TEfficiency class (see https://root.cern.ch/doc/master/classTEfficiency.html).</p> <p>The following conditions must be fulfilled for the calculation of the efficiency: * The bins of the histograms must be equal. * The histograms must be unweighted. * The bin contents of both histograms must be positive or zero. * The bin contents of h1 must be a subsample of the bin contents of h2.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram.</p> required <p>Returns:</p> Name Type Description <code>efficiency_values</code> <code>ndarray</code> <p>The efficiency values.</p> <code>efficiency_uncertainties</code> <code>ndarray</code> <p>The uncertainties on the efficiency values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the histograms are weighted.</p> <code>ValueError</code> <p>If the bin contents of the histograms are not positive or zero.</p> <code>ValueError</code> <p>If the bin contents of h1 are not a subsample of the bin contents of h2.</p>","boost":10},{"location":"api/#mplhep.comp.get_pull","title":"mplhep.comp.get_pull","text":"<pre><code>get_pull(h1, h2, h1_w2method='sqrt')\n</code></pre> <p>Compute the pull between two histograms.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The first histogram.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The second histogram.</p> required <code>h1_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for h1: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"sqrt\".</p> <code>'sqrt'</code> <p>Returns:</p> Name Type Description <code>pull_values</code> <code>ndarray</code> <p>The pull values.</p> <code>pull_uncertainties_low</code> <code>ndarray</code> <p>The lower uncertainties on the pull. Always ones.</p> <code>pull_uncertainties_high</code> <code>ndarray</code> <p>The upper uncertainties on the pull. Always ones.</p>","boost":10},{"location":"api/#mplhep.comp.get_ratio","title":"mplhep.comp.get_ratio","text":"<pre><code>get_ratio(h1, h2, h1_w2method='sqrt', ratio_uncertainty_type='uncorrelated')\n</code></pre> <p>Compute the ratio h1/h2 between two uncorrelated histograms h1 and h2.</p> <p>Parameters:</p> Name Type Description Default <code>h1</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The numerator histogram.</p> required <code>h2</code> <code>histogram(Hist, boost_histogram, histogram, TH1)</code> <p>The denominator histogram.</p> required <code>h1_w2method</code> <code>str</code> <p>What kind of bin uncertainty to use for h1: \"sqrt\" for the Poisson standard deviation derived from the variance stored in the histogram object, \"poisson\" for asymmetrical uncertainties based on a Poisson confidence interval. Default is \"sqrt\".</p> <code>'sqrt'</code> <code>ratio_uncertainty_type</code> <code>str</code> <p>How to treat the uncertainties of the histograms: * \"uncorrelated\" for the comparison of two uncorrelated histograms, * \"split\" for scaling down the uncertainties of h1 by bin contents of h2, i.e. assuming zero uncertainty coming from h2 in the ratio uncertainty. Default is \"uncorrelated\".</p> <code>'uncorrelated'</code> <p>Returns:</p> Name Type Description <code>ratio_values</code> <code>ndarray</code> <p>The ratio values.</p> <code>ratio_uncertainties_low</code> <code>ndarray</code> <p>The lower uncertainties on the ratio.</p> <code>ratio_uncertainties_high</code> <code>ndarray</code> <p>The upper uncertainties on the ratio.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ratio_uncertainty_type is not valid.</p>","boost":10},{"location":"api/#labeling","title":"Labeling","text":"","boost":10},{"location":"api/#mplhep.label","title":"mplhep.label","text":"<p>Labeling module.</p> <p>This module provides functions to create and manage HEP labels for plots.</p>","boost":10},{"location":"api/#mplhep.label.add_text","title":"mplhep.label.add_text","text":"<pre><code>add_text(text: str, loc: str | None = None, x: float | str | None = None, y: float | str | None = None, pad: float | None = None, xpad: float | None = None, ypad: float | None = None, fontsize: float | None = None, white_background: bool = False, text_class: type[Text] = mtext.Text, ax: Axes | None = None, **kwargs: Any) -&gt; mtext.Text\n</code></pre> <p>Add text to an axis with flexible positioning options.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add to the axes.</p> required <code>loc</code> <code>str | None</code> <p>Location shortcut similar to plt.legend(). Can be:</p> <ul> <li>Inside axes: \"upper left\", \"upper right\", \"lower left\", \"lower right\"</li> <li>Outside axes: \"over left\", \"over right\", \"under left\", \"under right\"</li> <li>Alternative spellings: \"top left\", \"top right\", \"bottom left\", \"bottom right\"</li> </ul> <p>If provided, overrides x and y parameters.</p> <code>None</code> <code>x</code> <code>float | str | None</code> <p>Horizontal position of the text in normalized axes coordinates (0-1). String aliases: \"left\", \"right\", \"left_in\", \"right_in\", \"right_out\". Ignored if loc is provided.</p> <code>None</code> <code>y</code> <code>float | str | None</code> <p>Vertical position of the text in normalized axes coordinates (0-1). String aliases: \"top\", \"bottom\", \"top_in\", \"bottom_in\", \"top_out\", \"bottom_out\". Ignored if loc is provided.</p> <code>None</code> <code>pad</code> <code>float | None</code> <p>Padding percentage from edges for \"in\" positions, by default 5.0. Applied to the shorter dimension and scaled proportionally for the longer dimension.</p> <code>None</code> <code>xpad</code> <code>float | None</code> <p>Horizontal padding percentage, overrides pad value for x-direction if provided.</p> <code>None</code> <code>ypad</code> <code>float | None</code> <p>Vertical padding percentage, overrides pad value for y-direction if provided.</p> <code>None</code> <code>fontsize</code> <code>int | float | None</code> <p>Font size, by default None (uses rcParams default).</p> <code>None</code> <code>white_background</code> <code>bool</code> <p>Draw a white rectangle under the text, by default False.</p> <code>False</code> <code>text_class</code> <code>type[Text]</code> <p>Text class to use for creating the text object, by default mtext.Text.</p> <code>Text</code> <code>ax</code> <code>Axes | None</code> <p>Axes object to add text to. If None, uses current axes.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the text constructor. Notably 'ha' (horizontal alignment) and 'va' (vertical alignment) are set automatically based on position but can be overridden.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both loc and x/y parameters are specified, or if x/y positions are not valid floats or recognized string aliases.</p> <p>Returns:</p> Type Description <code>Text</code> <p>The text object that was added to the axes.</p>","boost":10},{"location":"api/#mplhep.label.append_text","title":"mplhep.label.append_text","text":"<pre><code>append_text(s: str, txt_obj: Text, loc: str = 'right', pad: str | float = 'auto', ax: Axes | None = None, text_class: type[Text] = mtext.Text, _debug_x_override: float | None = None, **kwargs: Any) -&gt; mtext.Text\n</code></pre> <p>Append text relative to an existing text object.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The text string to append.</p> required <code>txt_obj</code> <code>Text</code> <p>The existing text object to append to.</p> required <code>loc</code> <code>str</code> <p>Location relative to the existing text. Options are \"right\", \"below\", \"above\", or \"left\".</p> <code>\"right\"</code> <code>pad</code> <code>str | float</code> <p>Padding between texts. If \"auto\", uses automatic spacing. If float, specifies padding as percentage of axes size.</p> <code>\"auto\"</code> <code>ax</code> <code>Axes | None</code> <p>Axes object. If None, uses current axes.</p> <code>None</code> <code>text_class</code> <code>type[Text]</code> <p>Text class to use for creating the new text object.</p> <code>Text</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the text constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Text</code> <p>The appended text object.</p>","boost":10},{"location":"api/#mplhep.label.exp_text","title":"mplhep.label.exp_text","text":"<pre><code>exp_text(exp: str = '', text: str = '', supp: str | None = None, lumi: str | None = None, loc: int | None = None, *, ax: Axes | None = None, fontsize: float | str | tuple[float | str, float | str, float | str, float | str] | None = None, fontweight: tuple[str, str, str, str] = ('bold', 'normal', 'normal', 'normal'), fontstyle: tuple[str, str, str, str] = ('normal', 'italic', 'normal', 'normal'), scilocator_adjust: bool = True, **kwargs: Any) -&gt; tuple[mtext.Text, mtext.Text | None, mtext.Text | None, mtext.Text | None]\n</code></pre> <p>Add typical LHC experiment primary label to the axes.</p> <p>Parameters:</p> Name Type Description Default <code>exp</code> <code>str</code> <p>Experiment name, by default \"\".</p> <code>''</code> <code>text</code> <code>str</code> <p>Secondary experiment label, typically not-bold and smaller font-size. For example \"Simulation\" or \"Preliminary\", by default \"\".</p> <code>''</code> <code>supp</code> <code>str | None</code> <p>Supplementary text to add (e.g., \"Private Work\"), by default None.</p> <code>None</code> <code>lumi</code> <code>str</code> <p>Luminosity information text, by default None.</p> <code>None</code> <code>loc</code> <code>int | None</code> <p>Label position: - 0 : Above axes, left aligned - 1 : Top left corner - 2 : Top left corner, multiline - 3 : Split EXP above axes, rest of label in top left corner - 4 : ATLAS-style (top left corner with luminosity below) By default None (uses 0).</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched), by default None.</p> <code>None</code> <code>fontsize</code> <code>int | float | str | tuple[float | str, float | str, float | str, float | str]</code> <p>Font size specification. Can be: - None: Uses rcParams default with relative scaling (exp=1.3x, text=1x, lumi=0.77x, supp=0.77x) - float: Base size with relative scaling applied - str: Matplotlib size string (\"small\", \"large\", etc.) with relative scaling applied - tuple: (exp_size, text_size, lumi_size, supp_size) for explicit control   Each element can be float or matplotlib size string</p> <code>None</code> <code>fontweight</code> <code>tuple[str, str, str, str]</code> <p>Tuple of fontweights for (exp, text, lumi, supp), by default (\"bold\", \"normal\", \"normal\", \"normal\").</p> <code>('bold', 'normal', 'normal', 'normal')</code> <code>fontstyle</code> <code>tuple[str, str, str, str]</code> <p>Tuple of fontstyles for (exp, text, lumi, supp), by default (\"normal\", \"italic\", \"normal\", \"normal\").</p> <code>('normal', 'italic', 'normal', 'normal')</code> <code>scilocator_adjust</code> <code>bool</code> <p>Whether to automatically adjust label position to accommodate scientific notation offset that appears on axes (e.g., \"x10\u00b3\" on y-axis). Only applies to loc positions 0 and 3 (above axes), by default True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to text functions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Text, Text | None, Text | None, Text | None]</code> <p>Tuple of text objects: (exp_label, secondary_text, luminosity_text, supplementary_text). Elements are None if not created.</p>","boost":10},{"location":"api/#mplhep.label.exp_label","title":"mplhep.label.exp_label","text":"<pre><code>exp_label(*, exp: str = '', text: str = '', supp: str | None = None, loc: int | None = None, data: bool = False, year: str | float | None = None, lumi: str | float | None = None, lumi_format: str = '{0}', com: str | float | None = None, llabel: str | None = None, rlabel: str | None = None, fontsize: float | str | tuple[float | str, float | str, float | str, float | str] | None = None, fontweight: tuple[str, str, str, str] = ('bold', 'normal', 'normal', 'normal'), fontstyle: tuple[str, str, str, str] = ('normal', 'italic', 'normal', 'normal'), label: str | None = None, pub: Any = None, scilocator_adjust: bool = True, ax: Axes | None = None, **kwargs: Any) -&gt; tuple[mtext.Text, mtext.Text | None, mtext.Text | None, mtext.Text | None]\n</code></pre> <p>A convenience wrapper for adding experiment labels with luminosity information.</p> <p>This function combines experiment text and luminosity information in a single call, providing common labeling layouts for LHC experiment plots.</p> <p>Parameters:</p> Name Type Description Default <code>exp</code> <code>str</code> <p>Experiment name (e.g., \"CMS\", \"ATLAS\"), by default \"\".</p> <code>''</code> <code>text</code> <code>str</code> <p>Secondary text to append after experiment name, typically \"Preliminary\", \"Supplementary\", \"Private Work\", or \"Work in Progress\", by default \"\".</p> <code>''</code> <code>supp</code> <code>str | None</code> <p>Supplementary text to add below main label, by default None.</p> <code>None</code> <code>loc</code> <code>int | None</code> <p>Label position layout: - 0 : Above axes, left aligned - 1 : Top left corner, single line - 2 : Top left corner, multiline - 3 : Split - experiment above axes, secondary text in top left corner - 4 : ATLAS-style - top left corner with luminosity below By default None (uses 0).</p> <code>None</code> <code>data</code> <code>bool</code> <p>If False, prepends \"Simulation\" to the label text. Default False.</p> <code>False</code> <code>year</code> <code>str | float | None</code> <p>Year when data was collected, by default None.</p> <code>None</code> <code>lumi</code> <code>str | float | None</code> <p>Integrated luminosity value in fb\u207b\u00b9, by default None.</p> <code>None</code> <code>lumi_format</code> <code>str</code> <p>Format string for luminosity display, by default \"{0}\". Example: \"{0:.1f}\" for one decimal place.</p> <code>'{0}'</code> <code>com</code> <code>str | float | None</code> <p>Center-of-mass energy in TeV, by default None (uses 13). Common values: 7, 8, 13, 13.6, 14.</p> <code>None</code> <code>llabel</code> <code>str | None</code> <p>Manual override for left-hand label text. Overrides \"data\" and \"text\" parameters.</p> <code>None</code> <code>rlabel</code> <code>str | None</code> <p>Manual override for right-hand label text. Overrides \"year\", \"lumi\", \"com\" parameters.</p> <code>None</code> <code>fontsize</code> <code>int | float | str | tuple[float | str, float | str, float | str, float | str] | None</code> <p>Font size specification: - None: Uses rcParams default with relative scaling - float/int: Base size with relative scaling applied - str: Matplotlib size string (\"small\", \"large\", etc.) with relative scaling - tuple: (exp_size, text_size, lumi_size, supp_size) for explicit control</p> <code>None</code> <code>fontweight</code> <code>tuple[str, str, str, str]</code> <p>Font weights for (exp, text, lumi, supp) elements, by default (\"bold\", \"normal\", \"normal\", \"normal\").</p> <code>('bold', 'normal', 'normal', 'normal')</code> <code>fontstyle</code> <code>tuple[str, str, str, str]</code> <p>Font styles for (exp, text, lumi, supp) elements, by default (\"normal\", \"italic\", \"normal\", \"normal\").</p> <code>('normal', 'italic', 'normal', 'normal')</code> <code>scilocator_adjust</code> <code>bool</code> <p>Whether to automatically adjust label position to accommodate scientific notation offset that appears on axes (e.g., \"x10\u00b3\" on y-axis). Only applies to loc positions 0 and 3 (above axes), by default True.</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>Axes object to add labels to. If None, uses current axes.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to text functions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Text, Text | None, Text | None, Text | None]</code> <p>Tuple of text objects: (exp_label, secondary_text, luminosity_text, supplementary_text). Elements are None if not created.</p>","boost":10},{"location":"api/#mplhep.label.savelabels","title":"mplhep.label.savelabels","text":"<pre><code>savelabels(fname: str = '', ax: Axes | None = None, labels: list[tuple[str, str]] | list[str] | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Save multiple copies of a figure with different label variations.</p> <p>This function automatically generates multiple versions of a plot with different experiment label text variations, useful for creating preliminary and final versions of plots.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Primary filename to be passed to <code>plt.savefig</code>. Can include path and extension.</p> <code>''</code> <code>ax</code> <code>Axes | None</code> <p>Axes object containing the labels to modify. If None, uses current axes.</p> <code>None</code> <code>labels</code> <code>list[tuple[str, str]] | list[str] | None</code> <p>Label variations to create. Can be:</p> <ul> <li>None: Uses default variations [(\"\", \"\"), (\"Preliminary\", \"pas\"),   (\"Supplementary\", \"supp\"), (\"Work in Progress\", \"wip\")]</li> <li>List of strings: Creates filename suffixes automatically</li> <li>List of tuples: (label_text, filename_suffix) pairs</li> </ul> <p>If filename suffix contains \".\" it's treated as absolute filename. If current label contains \"Simulation\", it will be preserved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to <code>plt.savefig</code>.</p> <code>{}</code>","boost":10},{"location":"api/#mplhep.label.save_variations","title":"mplhep.label.save_variations","text":"<pre><code>save_variations(fig: Figure, name: str, text_list: list[str] | None = None, exp: str | None = None) -&gt; None\n</code></pre> <p>Lite <code>savelabels</code></p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure object to save variations of.</p> required <code>name</code> <code>str</code> <p>Savename to pass to <code>plt.savefig()</code>.</p> required <code>text_list</code> <code>list[str] | None</code> <p>Variations of ExpText text object to cycle through, by default None.</p> <code>None</code> <code>exp</code> <code>str | None</code> <p>Change experiment name label, by default None.</p> <code>None</code>","boost":10},{"location":"api/#utilities","title":"Utilities","text":"","boost":10},{"location":"api/#mplhep.utils","title":"mplhep.utils","text":"","boost":10},{"location":"api/#mplhep.utils.merge_legend_handles_labels","title":"mplhep.utils.merge_legend_handles_labels","text":"<pre><code>merge_legend_handles_labels(handles, labels)\n</code></pre> <p>Merge handles for identical labels. This is useful when combining multiple plot functions into a single label.</p> <p>handles : List of handles labels : List of labels</p>","boost":10},{"location":"api/#mplhep.utils.set_fitting_ylabel_fontsize","title":"mplhep.utils.set_fitting_ylabel_fontsize","text":"<pre><code>set_fitting_ylabel_fontsize(ax: Axes) -&gt; float\n</code></pre> <p>Get the suitable font size for a ylabel text that fits within the plot's y-axis limits.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib subplot to adjust the ylabel font size for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The adjusted font size for the ylabel text.</p>","boost":10},{"location":"api/#mplhep.utils.yscale_legend","title":"mplhep.utils.yscale_legend","text":"<pre><code>yscale_legend(ax: Axes | None = None, otol: float = 0, soft_fail: bool = False, N: int = 10) -&gt; mpl.axes.Axes\n</code></pre> <p>Automatically scale y-axis up to fit in legend().</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>otol</code> <code>float</code> <p>Tolerance for overlap, default 0. Set <code>otol &gt; 0</code> for less strict scaling.</p> <code>0</code> <code>soft_fail</code> <code>bool</code> <p>Set <code>soft_fail=True</code> to return even if it could not fit the legend.</p> <code>False</code> <code>N</code> <code>int</code> <p>Maximum number of scaling iterations, default 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code>","boost":10},{"location":"api/#mplhep.utils.yscale_anchored_text","title":"mplhep.utils.yscale_anchored_text","text":"<pre><code>yscale_anchored_text(ax: Axes | None = None, otol: float = 0, soft_fail: bool = False, N: int = 3) -&gt; mpl.axes.Axes\n</code></pre> <p>Automatically scale y-axis up to fit AnchoredText</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>otol</code> <code>float</code> <p>Tolerance for overlap, default 0. Set <code>otol &gt; 0</code> for less strict scaling.</p> <code>0</code> <code>soft_fail</code> <code>bool</code> <p>Set <code>soft_fail=True</code> to return even if it could not fit the legend.</p> <code>False</code> <code>N</code> <code>int</code> <p>Maximum number of scaling iterations, default 10.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code>","boost":10},{"location":"api/#mplhep.utils.set_ylow","title":"mplhep.utils.set_ylow","text":"<pre><code>set_ylow(ax: Axes | None = None, ylow: float | None = None) -&gt; mpl.axes.Axes\n</code></pre> <p>Set lower y limit to 0 or a specific value if not data/errors go lower.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>ylow</code> <code>float</code> <p>Set lower y limit to a specific value.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code>","boost":10},{"location":"api/#mplhep.utils.mpl_magic","title":"mplhep.utils.mpl_magic","text":"<pre><code>mpl_magic(ax=None, ylow: float | None = None, otol=1, soft_fail=False, N=2)\n</code></pre> <p>Consolidate all ex-post style adjustments:     ylow     yscale_legend     yscale_anchored_text</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes object (if None, last one is fetched or one is created)</p> <code>None</code> <code>ylow</code> <code>float</code> <p>Set lower y limit to a specific value for ylow function</p> <code>None</code> <code>otol</code> <code>float</code> <p>Tolerance for overlap for yscale_legend, default 0</p> <code>1</code> <code>soft_fail</code> <code>bool</code> <p>Set to True to return even if legend could not fit in 10 iterations</p> <code>False</code> <code>N</code> <code>int</code> <p>Maximum number of scaling iterations for yscale functions, default 10</p> <code>2</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code>","boost":10},{"location":"api/#mplhep.utils.rescale_to_axessize","title":"mplhep.utils.rescale_to_axessize","text":"<pre><code>rescale_to_axessize(ax, w, h)\n</code></pre> <p>Adjust figure size to axes size in inches Parameters: w, h: width, height in inches</p>","boost":10},{"location":"api/#mplhep.utils.box_aspect","title":"mplhep.utils.box_aspect","text":"<pre><code>box_aspect(ax, aspect=1)\n</code></pre> <p>Adjust figure size to axes size in inches Parameters: aspect: float, optional aspect ratio</p>","boost":10},{"location":"api/#mplhep.utils.make_square_add_cbar","title":"mplhep.utils.make_square_add_cbar","text":"<pre><code>make_square_add_cbar(ax, size=0.4, pad=0.1)\n</code></pre> <p>Make input axes square and return an appended axes to the right for a colorbar. Both axes resize together to fit figure automatically. Works with tight_layout().</p>","boost":10},{"location":"api/#mplhep.utils.append_axes","title":"mplhep.utils.append_axes","text":"<pre><code>append_axes(ax, size=0.1, pad=0.1, position='right', extend=False)\n</code></pre> <p>Append a side ax to the current figure and return it. Figure is automatically extended along the direction of the added axes to accommodate it. Unfortunately can not be reliably chained.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to append to</p> required <code>size</code> <code>float or str</code> <p>Size of the appended axes. If str ending with '%', interpreted as percentage of parent axes size.</p> <code>0.1</code> <code>pad</code> <code>float or str</code> <p>Padding between axes. If str ending with '%', interpreted as percentage of parent axes size.</p> <code>0.1</code> <code>position</code> <code>str</code> <p>Position of appended axes ('right', 'left', 'top', 'bottom')</p> <code>'right'</code> <code>extend</code> <code>bool</code> <p>Whether to extend the figure size to accommodate the new axes</p> <code>False</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The appended axes object</p>","boost":10},{"location":"api/#mplhep.utils.sort_legend","title":"mplhep.utils.sort_legend","text":"<pre><code>sort_legend(ax, order=None)\n</code></pre> <p>ax : axes with legend labels in it order : Ordered dict with renames or array with order</p>","boost":10},{"location":"api/#mplhep.utils.subplots","title":"mplhep.utils.subplots","text":"<pre><code>subplots(figsize: tuple[float, float] | None = None, nrows: int = 1, gridspec_kw: dict | None = None, hspace: float = 0.15, *args, **kwargs) -&gt; tuple[plt.Figure, np.ndarray]\n</code></pre> <p>Wrapper around plt.subplots to create a figure with multiple subplots. Conveniently adjusts the figure size and spacing between subplots if multiple rows are requested.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size in inches. Default will adjust height based on number of rows.</p> <code>None</code> <code>nrows</code> <code>int</code> <p>Number of rows in the subplot grid. Default is 1.</p> <code>1</code> <code>gridspec_kw</code> <code>dict | None</code> <p>Additional keyword arguments for the GridSpec. Default is None. If None is provided and nrows &gt; 1, height_ratios will be set to give more space to the top subplot.</p> <code>None</code> <code>hspace</code> <code>float</code> <p>Height spacing between subplots. Default is 0.15.</p> <code>0.15</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The created figure.</p> <code>axes</code> <code>ndarray</code> <p>Array of Axes objects representing the subplots.</p>","boost":10},{"location":"api/#blinding","title":"Blinding","text":"<p>UHI-like value-based bin locator.</p> <p>Use <code>loc(value)</code> to create a locator for a single value, or <code>loc[start:stop]</code> to create a slice of locators.</p> <p>When both sides of the slice are plain numbers (no <code>j</code> suffix), they are treated as value-based (the purpose of <code>loc</code>). When at least one side uses the complex-number <code>j</code> suffix (UHI convention), the <code>j</code>-suffixed side is value-based and any plain-int side is index-based, enabling mixed specs like <code>loc[5:10j]</code>.</p>","boost":10},{"location":"api/#experiment-styling","title":"Experiment styling","text":"","boost":10},{"location":"api/#mplhep.style","title":"mplhep.style","text":"<p>Styling module.</p> <p>This module provides matplotlib stylesheets for various HEP experiments.</p>","boost":10},{"location":"api/#mplhep.style.use","title":"mplhep.style.use","text":"<pre><code>use(styles=None)\n</code></pre> <p>Set the experiment specific plotting style</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; import mplhep as mh\n&gt;&gt;&gt; mh.style.use(\"ATLAS\")\n&gt;&gt;&gt; mh.style.use(mh.style.CMS)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>str or style or dict or None</code> <p>The experiment style. Will understand a dictionary of rcParams, a mplhep style or its string alias. Pass <code>None</code> to reset to mpl defaults.</p> <code>None</code>","boost":10},{"location":"api/#mplhep.atlas","title":"mplhep.atlas","text":"","boost":10},{"location":"api/#mplhep.atlas.label","title":"mplhep.atlas.label","text":"<pre><code>label(text=None, **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.atlas.text","title":"mplhep.atlas.text","text":"<pre><code>text(text='', **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.cms","title":"mplhep.cms","text":"","boost":10},{"location":"api/#mplhep.cms.label","title":"mplhep.cms.label","text":"<pre><code>label(text=None, label=None, **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.cms.text","title":"mplhep.cms.text","text":"<pre><code>text(text='', **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.lhcb","title":"mplhep.lhcb","text":"<p>LHCb-like plot styles</p> <p>All of these styles resemble the LHCb plotting style; however it is an approximation and not an official style. The style <code>LHCb</code> should improve over time by inputs and may be changed in the future in favor of  a style that resembles morethe actual LHCb style.</p> <p>To use a specific style, use <code>LHCb1</code>, <code>LHCb2</code> etc. as they won't change in the future.</p> <p>Notes on LHCb2 style:</p> <p>An updated version of <code>LHCb</code> that includes minor ticks by default on and on all axes as well as improved legends and larger minus sign (by using unicode).</p> <p>Contributed and adjusted by Jonas Eschle Jonas.Eschle@cern.ch based on the works of Kevin Dungs, Tim Head, Thomas Schietinger,                       Andrew Powell, Chris Parkes, Elena Graverini                       and Niels Tuning</p>","boost":10},{"location":"api/#mplhep.lhcb.label","title":"mplhep.lhcb.label","text":"<pre><code>label(text=None, label=None, **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.lhcb.text","title":"mplhep.lhcb.text","text":"<pre><code>text(text='', **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.alice","title":"mplhep.alice","text":"","boost":10},{"location":"api/#mplhep.alice.label","title":"mplhep.alice.label","text":"<pre><code>label(text=None, label=None, **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.alice.text","title":"mplhep.alice.text","text":"<pre><code>text(text='', **kwargs)\n</code></pre>","boost":10},{"location":"api/#mplhep.dune","title":"mplhep.dune","text":"","boost":10},{"location":"api/#mplhep.dune.label","title":"mplhep.dune.label","text":"<pre><code>label(text=None, label=None, **kwargs)\n</code></pre> <p>Add DUNE experiment label to a plot.</p>","boost":10},{"location":"api/#mplhep.dune.text","title":"mplhep.dune.text","text":"<pre><code>text(text='', **kwargs)\n</code></pre> <p>Add DUNE experiment text to a plot.</p>","boost":10},{"location":"gallery/","title":"Overview","text":""},{"location":"gallery/#gallery","title":"Gallery","text":""},{"location":"gallery/#1d-histogram-comparisons","title":"1D Histogram Comparisons","text":"<p>Asymmetry comparison</p> <p></p><p>Difference comparison</p> <p></p><p>Efficiency comparison</p> <p></p><p>Only efficiency comparison</p> <p></p><p>Pull comparison</p> <p></p><p>Ratio comparison</p> <p></p><p>Relative difference comparison</p> <p></p><p>Split ratio comparison</p>"},{"location":"gallery/#model-comparisons","title":"Model Comparisons","text":"<p>Model all comparisons</p> <p></p><p>Model all comparisons no model uncertainty</p> <p></p><p>Model examples pull</p> <p></p><p>Model examples pull no model uncertainty</p> <p></p><p>Model examples stacked</p> <p></p><p>Model examples stacked unstacked</p> <p></p><p>Model examples unstacked</p> <p></p><p>Model with stacked and unstacked function components</p> <p></p><p>Model with stacked and unstacked histograms components</p> <p></p><p>Ratio data vs model with stacked and unstacked function components</p>"},{"location":"guide/","title":"User Guide","text":"<p>Welcome to the mplhep user guide! This documentation is organized into focused sections to help you find what you need quickly.</p> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\nmh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide/#histogram-plotting","title":"Histogram Plotting","text":"<p>Functions for 1D and 2D pre-binned histograms with support for the Unified Histogram Interface (UHI).</p> <ul> <li>1D Histogram Plotting<ul> <li>Supported Input Formats</li> <li>Histogram Styles</li> <li>Multiple Histograms</li> <li>Blinding</li> <li>Error Bars</li> <li>Normalization Options</li> </ul> </li> <li>2D Histograms</li> </ul>"},{"location":"guide/#comparison-plotting","title":"Comparison Plotting","text":"<p>High-level functions for data-model comparisons.</p> <ul> <li>Compare two histograms</li> <li>Data-MC comparison<ul> <li>Showcasing more options</li> </ul> </li> <li>Blinding in Comparisons</li> <li>Additional examples</li> </ul>"},{"location":"guide/#styling","title":"Styling","text":"<p>Official styles for ATLAS, CMS, LHCb, ALICE, and DUNE experiments.</p> <ul> <li>Setting experiment styles</li> <li>Setting experiment labels</li> <li>Configuring experiment labels</li> </ul>"},{"location":"guide/#utilities","title":"Utilities","text":"<p>Utility functions and experiment-specific label formatters.</p> <ul> <li>Text placement</li> <li>Subplot creation</li> <li>Save variations</li> <li>Fit y-label</li> <li>mpl_magic</li> <li>Axes manipulation</li> <li>plt.hist wrapper</li> </ul>"},{"location":"guide/#to-go-further","title":"To go further","text":"<p>UHI integration and best practices.</p> <ul> <li>Working with UHI Histograms</li> <li>Best practices</li> </ul>"},{"location":"guide/#more-info","title":"More Info","text":"<ul> <li>API Reference - Detailed documentation of all functions and parameters</li> <li>Gallery - Visual examples of all plot types</li> <li>Contributing - Information on development and testing</li> </ul>"},{"location":"guide/#getting-help","title":"Getting Help","text":"<ul> <li>Check the GitHub repository for issues</li> <li>Ask questions in the scikit-hep discussions</li> </ul>"},{"location":"guide_advanced/","title":"To go further","text":"<p>This section covers advanced mplhep features and utilities..</p> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\n# mh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide_advanced/#working-with-uhi-histograms","title":"Working with UHI Histograms","text":"<p>mplhep fully supports the Unified Histogram Interface, making it compatible with modern histogram libraries:</p> <pre><code>import hist\nimport boost_histogram as bh\n\n# Using hist library\nh = hist.Hist(hist.axis.Regular(50, -3, 3, name='x', label='Observable [GeV]'))\nh.fill(data)\nmh.histplot(h)  # Automatically uses axis labels\n\n# Using boost_histogram\nh_boost = bh.Histogram(bh.axis.Regular(50, -3, 3))\nh_boost.fill(data)\nmh.histplot(h_boost)\n\n# From ROOT files via uproot\nimport uproot\nfile = uproot.open('data.root')\nh_root = file['histogram_name']\nmh.histplot(h_root)\n</code></pre>"},{"location":"guide_advanced/#best-practices","title":"Best Practices","text":""},{"location":"guide_advanced/#consistent-binning","title":"Consistent Binning","text":"<p>When plotting multiple histograms together, ensure they share the same binning:</p> <pre><code># Define bins once\nbins = np.linspace(-4, 4, 41)\n\n# Use same bins for all histograms\nh1 = np.histogram(data1, bins=bins)\nh2 = np.histogram(data2, bins=bins)\n\nmh.histplot([h1[0], h2[0]], bins=bins)\n</code></pre>"},{"location":"guide_advanced/#error-representation","title":"Error Representation","text":"<p>Always show uncertainties for data:</p> <pre><code># For data points\nmh.histplot(data_hist, bins=bins, yerr=True, histtype='errorbar', label='Data')\n\n# For Monte Carlo, consider filled uncertainty bands\nmh.histplot(mc_hist, bins=bins, histtype='fill', alpha=0.3, label='MC')\n</code></pre>"},{"location":"guide_advanced/#axis-labels-with-units","title":"Axis Labels with Units","text":"<p>Include units in axis labels following HEP conventions:</p> <pre><code>ax.set_xlabel('Mass [GeV]')\nax.set_ylabel('Events / 5 GeV')  # Include bin width\n</code></pre>"},{"location":"guide_advanced/#using-legends","title":"Using Legends","text":"<p>Place legends appropriately and use clear labels:</p> <pre><code>mh.histplot([h1, h2], bins=bins, label=['Signal', 'Background'])\nax.legend(loc='upper right', frameon=False)\n</code></pre>"},{"location":"guide_advanced/#style-consistency","title":"Style Consistency","text":"<p>Apply styles at the beginning of your script, not in functions:</p> <pre><code># At the top of your script\nimport mplhep as mh\nmh.style.use('CMS')\n\n# Then create all plots\n# ...\n</code></pre>"},{"location":"guide_basic_plotting/","title":"Basic Plotting","text":"<p>This section covers the core plotting functionality of mplhep for plotting 1D and 2D histograms.</p> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\n# mh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide_basic_plotting/#1d-histogram-plotting","title":"1D Histogram Plotting","text":"<p><code>mh.histplot()</code> works with multiple histogram formats through the UHI protocol:</p>"},{"location":"guide_basic_plotting/#supported-input-formats","title":"Supported Input Formats","text":"DefaultplothistCMSATLASLHCbALICEDUNE Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre> Array-Like<code>numpy.histogram</code><code>hist.Hist</code><code>uproot.TH1</code> <pre><code>fig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nfig, ax = plt.subplots()\nmh.histplot(*np.histogram(data, bins=40), ax=ax)\n</code></pre> <pre><code>data = np.random.normal(0, 1, 1000)\nh_obj = hist.new.Reg(40, -4, 4).Weight().fill(data)\nfig, ax = plt.subplots()\nmh.histplot(h_obj, ax=ax)\n# Note that errorbars are now automatically plotted because hist.Hist inputs objects has .variances() available\n</code></pre> <pre><code>import uproot\n\nfile = uproot.open(uproot_file_name)\nh_root = file['hpx']\nfig, ax = plt.subplots()\nmh.histplot(h_root, ax=ax)\n</code></pre>"},{"location":"guide_basic_plotting/#histogram-styles","title":"Histogram Styles","text":"<p>Control the appearance with the <code>histtype</code> parameter. Select an experiment style and then choose a histogram type:</p> DefaultplothistCMSATLASLHCbALICEDUNE StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre> StepFillErrorbarBandBarBarstep <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='step', label='Step histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='fill', alpha=0.5, label='Filled histogram', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', label='Data', ax=ax)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='band', alpha=0.5, label='Band histogram', ax=ax)\n# Can be used to visualize uncertainties\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='bar', label='Bar histogram', ax=ax)\n# If only one histogram is provided, it will be treated as \"fill\" histtype, if multiple data are given the bars are arranged side by side (see next section)\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='barstep', label='Barstep histogram', ax=ax)\n# If one histogram is provided, it will be treated as \"step\" histtype. If multiple data are given the bars are arranged side by side (see next section)\n</code></pre>"},{"location":"guide_basic_plotting/#multiple-histograms","title":"Multiple Histograms","text":""},{"location":"guide_basic_plotting/#stack","title":"Stack","text":"<p><code>mh.histplot()</code> supports plotting multiple histograms in one call. They can be stacked using the <code>stack=True</code> parameter:</p> DefaultplothistCMSATLASLHCbALICEDUNE Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\n\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\ntxt_obj = mh.add_text('plothist', loc='over left')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nmh.cms.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nmh.atlas.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nmh.lhcb.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nmh.alice.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Unstacked fillStacked fillSorted (by yield)Sorted (by label)Sorted (by label - reversed)With errorbars <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n alpha=0.7,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='yield',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='label',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='fill',\n stack=True,\n sort='l_r',\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(-1, 0.8, 800))\nh2 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(2, 0.6, 600))\nh3 = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0.5, 1.2, 1200))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n stack=True,\n label=['Background 1', 'Background 2', 'Signal'],\n ax=ax\n)\nmh.dune.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre>"},{"location":"guide_basic_plotting/#side-by-side","title":"Side by Side","text":"<p>When plotting multiple histograms, the <code>histtype</code> can be set to <code>'bar'</code> or <code>'barstep'</code> to create side-by-side bar plots, just like <code>matplotlib</code>:</p> DefaultplothistCMSATLASLHCbALICEDUNE BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\n\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\n\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\ntxt_obj = mh.add_text('plothist', loc='over left')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\ntxt_obj = mh.add_text('plothist', loc='over left')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.cms.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.cms.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.atlas.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.atlas.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.lhcb.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.lhcb.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.alice.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.alice.label(data=False)\nmh.mpl_magic(soft_fail=True)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> BarBarstep <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='bar',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.dune.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre> <pre><code># Create histograms and fill them\nh1 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(0.5, 200))\nh2 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.0, 300))\nh3 = hist.new.Reg(6, 0, 6).Weight().fill(np.random.poisson(1.2, 500))\n\nfig, ax = plt.subplots()\nmh.histplot(\n [h1, h2, h3],\n histtype='barstep',\n label=['$h_1$', '$h_2$', '$h_3$'],\n ax=ax\n)\nmh.dune.label(data=False)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n# Optional: move the x-ticks to the bin centers\nax.set_xticks(h1.axes[0].centers)\nax.set_xticklabels([x+0.5 for x in h1.axes[0].centers])\nax.minorticks_off()\n</code></pre>"},{"location":"guide_basic_plotting/#blinding","title":"Blinding","text":"<p>Blinding allows you to hide specific regions of a histogram, which is useful for blind analyses where signal regions should not be examined until the analysis is finalized. The <code>blind</code> parameter in <code>mh.histplot()</code> supports multiple specification formats to accommodate different use cases.</p> Blinding syntax overview <p>Blinding regions can be specified in several ways:</p> <ul> <li>Value-based: Specify physical values (coordinates) using tuples or <code>j</code> suffix</li> <li>Index-based: Specify bin indices directly using integers</li> <li>Multiple regions: Use a list to blind multiple regions at once</li> </ul> <p>All formats can be combined in a list for maximum flexibility.</p>"},{"location":"guide_basic_plotting/#value-based-blinding","title":"Value-Based Blinding","text":"<p>Blind a region by specifying physical values (coordinates) on the x-axis:</p> DefaultplothistCMSATLASLHCbALICEDUNE Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Tuple notationString with j suffixloc slice notation <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=(-1.0, 1.0), label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=\"-1j:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\nmh.histplot(h, ax=ax, blind=loc[-1.0:1.0], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre>"},{"location":"guide_basic_plotting/#index-based-blinding","title":"Index-Based Blinding","text":"<p>Blind specific bins by their index:</p> DefaultplothistCMSATLASLHCbALICEDUNE Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Single binRange of binsList of bins <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind the 20th bin (index 19)\nmh.histplot(h, ax=ax, blind=19, label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind bins 15 to 25 (indices 15-24)\nmh.histplot(h, ax=ax, blind=\"15:25\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind specific bins\nmh.histplot(h, ax=ax, blind=[18, 19, 20, 21, 22], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre>"},{"location":"guide_basic_plotting/#multiple-regions","title":"Multiple Regions","text":"<p>Blind multiple regions by providing a list of specifications:</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind multiple regions: value-based and index-based\nmh.histplot(h, ax=ax, blind=[(-2.5, -1.5), (1.5, 2.5), 5], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre>"},{"location":"guide_basic_plotting/#mixed-mode-blinding","title":"Mixed-Mode Blinding","text":"<p>Mix value-based and index-based specifications in the same slice:</p> DefaultplothistCMSATLASLHCbALICEDUNE Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> Index start, value endValue start, index end <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from bin 5 to value 1.0\nmh.histplot(h, ax=ax, blind=\"5:1j\", label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre> <pre><code>h = hist.new.Reg(40, -4, 4).Weight().fill(np.random.normal(0, 1, 1000))\nfig, ax = plt.subplots()\n# Blind from value -1.0 to bin 30\nmh.histplot(h, ax=ax, blind=loc[-1.0:30], label='Data')\nax.legend()\nax.set_xlabel('Observable [GeV]')\nax.set_ylabel('Events')\n</code></pre>"},{"location":"guide_basic_plotting/#error-bars","title":"Error Bars","text":"<p>Control error bar display with <code>yerr</code> and <code>w2method</code> parameters:</p> DefaultplothistCMSATLASLHCbALICEDUNE Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> Automatic (Poisson)Set explicitlySet yerr calculation method (<code>'sqrt'</code>/<code>'poisson'</code>)Set yerr calculation function - full control <pre><code># Simple histogram with Weight storage for automatic errors\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.poisson(5, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=True, label='Data with Poisson errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Simple histogram with custom error bars\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\ncustom_errors = np.minimum(np.sqrt(h.values()), np.random.uniform(0, 20, 20))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', yerr=custom_errors, label='Data with custom errors', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram - errors from sqrt of sum of weights squared\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method='sqrt', label='Weighted data (sqrt method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Weighted histogram with custom error calculation\nh = hist.new.Reg(20, 0, 20).Weight().fill(np.random.normal(10, 5, 2000))\n\n# Custom error function: error = sqrt(sum(weights^2)) / 2\ndef custom_w2_method(weights, variances):\n up = weights - np.ones_like(weights) * 0.2 * np.mean(weights)\n down = weights + np.ones_like(weights) * 0.2 * np.mean(weights)\n return up, down\n\nfig, ax = plt.subplots()\nmh.histplot(h, histtype='errorbar', w2method=custom_w2_method, label='Weighted data (custom error method)', ax=ax)\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre>"},{"location":"guide_basic_plotting/#normalization-options","title":"Normalization Options","text":"<p>Control histogram normalization with <code>density</code> and <code>binwnorm</code> parameters:</p> DefaultplothistCMSATLASLHCbALICEDUNE NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> NominalDensityBin Width Normalized <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'density': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Density')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre> <pre><code># Create histograms with different binning schemes\nbins1 = np.r_[np.linspace(-4, 0, 30)[:-1], np.linspace(0, 4, 10)] # Variable binning\nbins2 = np.linspace(-4, 4, 40) #  Regular binning\nh1 = hist.new.Var(bins1).Weight().fill(np.random.normal(0, 1, 2000))\nh2 = hist.new.Var(bins2).Weight().fill(np.random.normal(0, 1, 2000))\n\n# Plot\nkwargs = {'binwnorm': True}\nfig, ax = plt.subplots()\nmh.histplot(h1, histtype='fill', alpha=0.7, label='Variable bins (same data)', ax=ax, **kwargs)\nmh.histplot(h2, histtype='fill', alpha=0.7, label='Regular bins (same data)', ax=ax, **kwargs)\n\n# Style\nax.set_xlabel('Observable')\nax.set_ylabel('Events / Bin Width')\nax.legend(loc='upper right')\nmh.yscale_legend(soft_fail=True)\n</code></pre>"},{"location":"guide_basic_plotting/#2d-histograms","title":"2D Histograms","text":"<p>Use <code>mh.hist2dplot()</code> for 2D histogram visualization:</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre> <pre><code># Generate 2D data\nx = np.random.normal(0, 1, 5000)\ny = np.random.normal(0, 1, 5000)\nH, xedges, yedges = np.histogram2d(x, y, bins=30)\n\nfig, ax = plt.subplots()\nmh.hist2dplot(H, xedges, yedges, ax=ax, cbar=True)\nax.set_xlabel('Variable 1')\nax.set_ylabel('Variable 2')\n</code></pre>"},{"location":"guide_comparisons/","title":"Comparing histograms","text":"<p>mplhep provides dedicated comparison plotters in the <code>mh.comp</code> module for creating plots with different comparison panels. The following functions are available:</p> <ul> <li><code>mh.comp.hists()</code>: compare two histograms, plot the main plot and a comparison panel.</li> <li><code>mh.comp.data_model()</code>: compare a model made of histograms or functions to data, plot the main plot and a comparison panel.</li> <li><code>mh.comp.comparison()</code>: to only plot the comparison panel given two histograms.</li> <li><code>mh.comp.get_comparison()</code>: to get the <code>[values, lower_uncertainties, upper_uncertainties]</code> for a given comparison type.</li> </ul> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\n# mh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide_comparisons/#comparing-two-histograms","title":"Comparing two histograms","text":""},{"location":"guide_comparisons/#available-methods","title":"Available methods","text":"<p>To compare two histograms, use <code>mh.comp.hists()</code>. This function takes two histograms as input and creates a figure with a main plot showing both histograms and a comparison panel below it.</p> <p>The <code>comparison</code> parameter accepts:</p> <ul> <li><code>ratio</code>: \\(\\frac{\\text{h1}}{\\text{h2}}\\)</li> <li><code>split_ratio</code>: same as ratio, but the uncertainties of <code>h1</code> and <code>h2</code> are shown separately in the comparison panel (used extensively in data/model comparisons, see below)</li> <li><code>pull</code>: \\(\\frac{\\text{h1} - \\text{h2}}{\\sqrt{\\sigma_{\\text{h1}}^2 + \\sigma_{\\text{h2}}^2}}\\)</li> <li><code>difference</code>: \\(\\text{h1} - \\text{h2}\\)</li> <li><code>relative_difference</code>: \\(\\frac{\\text{h1} - \\text{h2}}{\\text{h2}}\\)</li> <li><code>asymmetry</code>: \\(\\frac{\\text{h1} - \\text{h2}}{\\text{h1} + \\text{h2}}\\)</li> <li><code>efficiency</code>: \\(\\frac{\\text{h1}}{\\text{h2}}\\) (with uncertainties from eq.19 here)</li> </ul> DefaultplothistCMSATLASLHCbALICEDUNE RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> RatioSplit ratioPullDifferenceRelative differenceAsymmetryEfficiency <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='split_ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='pull',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='relative_difference',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='asymmetry',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data and model\nx2 = np.random.normal(0, 1, 1000)\nx1 = np.random.choice(x2, size=500, replace=False)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1) # h1 needs to be a subset of h2\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n comparison='efficiency',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='h1',\n h2_label='h2'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre>"},{"location":"guide_comparisons/#only-plot-the-comparison-panel","title":"Only plot the comparison panel","text":"<p>To only plot the comparison panel given two histograms, use <code>mh.comp.comparison()</code>. This function takes two histograms as input and creates a figure with only the comparison panel.</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\ntxt_obj = mh.add_text('plothist', ax=ax)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\nmh.cms.label(data=True, lumi=100, ax=ax)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\nmh.atlas.label(data=True, lumi=150, ax=ax)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\nmh.alice.label(data=True, lumi=100, ax=ax)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data and model\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison panel only\nfig, ax = plt.subplots()\n\nmh.comp.comparison(\n h1,\n h2,\n comparison='ratio',\n xlabel='Observable [GeV]',\n h1_label='h1',\n h2_label='h2',\n ax=ax\n)\nmh.dune.label(data=True, lumi=100, ax=ax)\n</code></pre> <p>To get the <code>[values, lower_uncertainties, upper_uncertainties]</code> for a given comparison type without plotting, use <code>mh.comp.get_comparison()</code>:</p> <pre><code>values, lower_uncertainties, upper_uncertainties = mh.comp.get_comparison(\n    h1,\n    h2,\n    comparison='ratio'\n)\n</code></pre>"},{"location":"guide_comparisons/#data-mc-comparison","title":"Data-MC comparison","text":"<p>To compare data to a model made of multiple components (e.g. signal, backgrounds...), use <code>mh.comp.data_model()</code>. The function is very flexible, it can accept any number of stacked and/or unstacked components, either as histograms or functions. It will then compare the sum of the components to the data, with the comparison of your choice. The default comparison is the <code>split_ratio</code> between the model and the data. It can take any comparison method available in <code>mh.comp.hists()</code>.</p> DefaultplothistCMSATLASLHCbALICEDUNE StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> StackedMixed stacked and unstackedFunctions, stackedFunctions, mixed stacked and unstacked <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# The function will automatically sum the stacked and unstacked components\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * scipy.stats.norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * scipy.stats.norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1, f_signal],\n stacked_labels=['Bkg 2', 'Bkg 1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Define component functions\ndef f_signal(x):\n return 200 * norm.pdf(x, loc=0.5, scale=3)\ndef f_bkg1(x):\n return 500 * norm.pdf(x, loc=-1.5, scale=4)\ndef f_bkg2(x):\n return 500 * norm.pdf(x, loc=-1., scale=1.8)\n\n# Generate data histogram\nx_data = np.concatenate([np.random.normal(-1.5, 4, 1500), np.random.normal(-1., 1.8, 2000)])\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(x_data)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=data_hist,\n stacked_components=[f_bkg2, f_bkg1,],\n stacked_labels=['Bkg 2', 'Bkg 1'],\n unstacked_components=[f_signal],\n unstacked_labels=['Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <p>Tip</p> <p>To only plot the model, without data or comparison panel, use <code>mh.model()</code>. It takes the same arguments as <code>mh.comp.data_model()</code>, except for the <code>data_hist</code> and <code>comparison</code> parameters.</p>"},{"location":"guide_comparisons/#showcasing-more-options","title":"Showcasing more options","text":"<p><code>mh.comp.data_model()</code> is very flexible and can be customized further. For more examples and details, see the API Reference and the Gallery. Here is a selection of additional examples showcasing some of the available options.</p> DefaultplothistCMSATLASLHCbALICEDUNE Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\nmh.cms.label(data=True, lumi=100, ax=ax_main)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\nmh.atlas.label(data=True, lumi=150, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\nmh.lhcb.label(data=True, lumi=50, ax=ax_main)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\nmh.alice.label(data=True, lumi=100, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> Different comparisonRemove MC uncertaintiesModel kwargsPlot only 1 ax <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n comparison='pull' # Accept any comparison from mh.comp.comparison()\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n model_uncertainty=False, # Set the model uncertainty to zero\n comparison='pull', # The pull formula is updated automatically\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comp = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1],\n stacked_labels=['Bkg2', 'Bkg1'],\n stacked_colors=['grey', 'lightblue'],\n unstacked_components=[h_signal],\n unstacked_labels=['Signal'],\n unstacked_colors=['red'],\n model_sum_kwargs={\"show\": True, \"label\": \"Total Model\", \"color\": \"violet\"}, # Just like stacked_components_kwargs and unstacked_components_kwargs, you can pass kwargs for the model sum line\n xlabel='Observable [GeV]',\n ylabel='Events'\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre> <pre><code># Generate signal, backgrounds, and data\nx1 = np.random.normal(0, 1, 1400)\nx2 = np.random.normal(1, 0.5, 1000)\nx3 = np.random.exponential(0.5, 900) - 1.5\ndata_x = np.random.choice([*x1, *x2, *x3], size=3500, replace=True)\nh_bkg1 = hist.new.Reg(25, -3, 5).Weight().fill(x1)\nh_bkg2 = hist.new.Reg(25, -3, 5).Weight().fill(x2)\nh_signal = hist.new.Reg(25, -3, 5).Weight().fill(x3)\nh_data = hist.new.Reg(25, -3, 5).Weight().fill(data_x)\n\n# Create comparison plot\nfig, ax_main, ax_comparison = mh.comp.data_model(\n data_hist=h_data,\n stacked_components=[h_bkg2, h_bkg1, h_signal],\n stacked_labels=['Bkg2', 'Bkg1', 'Signal'],\n xlabel='Observable [GeV]',\n ylabel='Events',\n plot_only='ax_main' # Only plot the comparison axis (works with 'ax_comparison' as well).\n)\nmh.dune.label(data=True, lumi=100, ax=ax_main)\n</code></pre>"},{"location":"guide_comparisons/#blinding-in-comparisons","title":"Blinding in Comparisons","text":"<p>The <code>blind</code> parameter is available in comparison functions (<code>mh.comp.hists()</code>, <code>mh.comp.data_model()</code>) to hide specific regions in both the main plot and the comparison panel. This is particularly useful for blind analyses where signal regions should remain hidden until the analysis is finalized.</p> <p>For detailed information about blinding syntax and options, see the Blinding section in the Basic Plotting guide.</p>"},{"location":"guide_comparisons/#blinding-two-histogram-comparisons","title":"Blinding Two-Histogram Comparisons","text":"<p>Use <code>blind</code> with <code>mh.comp.hists()</code>:</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample data\nx1 = np.random.normal(0, 1, 1000)\nx2 = np.random.normal(0, 1.05, 1000)\nh1 = hist.new.Reg(25, -4, 4).Weight().fill(x1)\nh2 = hist.new.Reg(25, -4, 4).Weight().fill(x2)\n\n# Create comparison plot with blinded signal region\nfig, ax_main, ax_comp = mh.comp.hists(\n h1,\n h2,\n blind=(-1.0, 1.0), # Blind the region from -1 to 1 GeV\n comparison='ratio',\n xlabel='Observable [GeV]',\n ylabel='Events',\n h1_label='Data',\n h2_label='MC'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre>"},{"location":"guide_comparisons/#blinding-data-model-comparisons","title":"Blinding Data-Model Comparisons","text":"<p>Use <code>blind</code> with <code>mh.comp.data_model()</code> to blind signal regions in data-model comparisons:</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate sample background and data\nbkg1 = np.random.exponential(2.0, 800)\nbkg2 = np.random.exponential(1.5, 600)\ndata = np.concatenate([\n np.random.exponential(2.0, 800),\n np.random.exponential(1.5, 600)\n])\n\n# Create histograms\nh_bkg1 = hist.new.Reg(30, 0, 10).Weight().fill(bkg1)\nh_bkg2 = hist.new.Reg(30, 0, 10).Weight().fill(bkg2)\nh_data = hist.new.Reg(30, 0, 10).Weight().fill(data)\n\n# Create comparison plot with blinded region\nfig, ax_main, ax_comp = mh.comp.data_model(\n h_data,\n stacked_components=[h_bkg1, h_bkg2],\n stacked_labels=['Background 1', 'Background 2'],\n blind=(2.0, 4.0), # Blind potential signal region\n xlabel='Observable [GeV]',\n ylabel='Events',\n data_label='Data',\n comparison='split_ratio'\n)\nmh.dune.label(data=True, ax=ax_main)\n</code></pre>"},{"location":"guide_comparisons/#additional-examples","title":"Additional examples","text":"<p>The functions are very flexible, here is some additional examples showcasing more options and use cases. For more details, see the API Reference and the Gallery.</p> DefaultplothistCMSATLASLHCbALICEDUNE <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax_main)\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\nmh.cms.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\nmh.atlas.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\nmh.lhcb.label(data=True, ax=ax_main)\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\nmh.alice.label(data=True, ax=ax_main)\nmh.mpl_magic(soft_fail=True)\n</code></pre> <pre><code># Generate training and testing histograms for two classes\nx1_train = np.random.normal(0, 0.3, 2000)\nx1_test = np.random.normal(0, 0.3, 1000)\nx2_train = np.random.normal(1, 0.3, 2000)\nx2_test = np.random.normal(1, 0.3, 1000)\nh1_train = hist.new.Regular(30, 0, 1).Weight().fill(x1_train)\nh2_train = hist.new.Regular(30, 0, 1).Weight().fill(x2_train)\nh1_test = hist.new.Regular(30, 0, 1).Weight().fill(x1_test)\nh2_test = hist.new.Regular(30, 0, 1).Weight().fill(x2_test)\n\n# Since we have the histogram objects, we can normalize them directly\nh1_train /= h1_train.sum().value\nh2_train /= h2_train.sum().value\nh1_test /= h1_test.sum().value\nh2_test /= h2_test.sum().value\n\n# Using the wrapper around subplots\nfig, axes = mh.subplots(nrows=3)\n\ncolors = [\"C0\", \"C1\"]\nlabels = [\"Bkg\", \"Signal\"]\n\n# Plotting on the main axis\nfor k_hist, h in enumerate([h1_train, h2_train, h1_test, h2_test]):\n color = colors[k_hist % 2]\n label = labels[k_hist % 2]\n yerr = False if k_hist &lt; 2 else True # To make the plot less busy\n\n mh.histplot(\n h,\n color=color,\n label=label + (\" $_{Train}$\" if k_hist &lt;2 else \" $_{Test}$\"),\n ax=axes[0],\n yerr=yerr,\n histtype=\"step\" if k_hist &lt; 2 else \"errorbar\",\n )\n\n# Plotting comparisons on the other axes\nmh.comp.comparison(\n h1_train,\n h1_test,\n ax=axes[1],\n comparison=\"ratio\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[0],\n)\n\nmh.comp.comparison(\n h2_train,\n h2_test,\n ax=axes[2],\n comparison=\"pull\",\n h1_label=\"Train\",\n h2_label=\"Test\",\n color=colors[1],\n)\n\nfor ax in axes:\n ax.set_xlim(0, 1)\n\naxes[0].set_ylabel(\"Normalized Entries\")\naxes[0].legend()\naxes[1].set_ylabel(\"Ratio\")\naxes[2].set_ylabel(\"Pull\")\naxes[-1].set_xlabel(\"Feature\")\n\nfig.align_ylabels() # Align y labels\n\nmh.dune.label(data=True, ax=ax_main)\n</code></pre>"},{"location":"guide_styling/","title":"Styling and Customization","text":"<p>This section covers additional information about styling.</p> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\n# mh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide_styling/#setting-experiment-styles","title":"Setting experiment styles","text":"<p>Styles are applied globally using <code>mh.style.use()</code>, which is just a thin wrapper on <code>plt.style.use()</code>, with some extra goodies:</p> DefaultplothistCMSATLASLHCbALICEDUNE Style by nameStyle as a dictWith customizations <pre><code>mh.style.use()\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use()\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint()\n</code></pre> <pre><code>\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([{}, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('plothist')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.plothist)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.plothist)\n</code></pre> <pre><code>{'figure.figsize': (6, 4), 'figure.facecolor': 'white', 'font.size': 15, 'xtick.labelsize': 15, 'ytick.labelsize': 15, 'axes.labelsize': 18, 'legend.fontsize': 12, 'text.usetex': False, 'font.family': ['serif', 'sans-serif'], 'font.serif': ['Latin Modern Math', 'Latin Modern Roman'], 'font.sans-serif': ['Latin Modern Sans'], 'mathtext.fontset': 'cm', 'mathtext.default': 'regular', 'legend.frameon': False, 'legend.framealpha': 0.5, 'xtick.direction': 'in', 'ytick.direction': 'in', 'xtick.minor.visible': True, 'ytick.minor.visible': True, 'ytick.left': True, 'ytick.right': False, 'xtick.top': False, 'xtick.bottom': True, 'xtick.major.size': 6, 'ytick.major.size': 6, 'xtick.minor.size': 3, 'ytick.minor.size': 3, 'xtick.major.pad': 8.0, 'ytick.major.pad': 5.0, 'axes.axisbelow': False, 'image.cmap': 'viridis', 'grid.linestyle': '-', 'lines.solid_capstyle': 'round', 'axes.grid': False, 'axes.facecolor': 'white', 'axes.linewidth': 1, 'lines.linewidth': 1, 'patch.linewidth': 1, 'lines.markersize': 6, 'axes.formatter.limits': (-4, 4), 'axes.prop_cycle': cycler('color', ['#348ABD', '#E24A33', '#988ED5', '#777777', '#FBC15E', '#8EBA42', '#FFB5B8']), 'axes.formatter.use_mathtext': True, 'axes.formatter.useoffset': False, 'axes.labelpad': 6, 'errorbar.capsize': 0}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.plothist, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('CMS')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.CMS)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.CMS)\n</code></pre> <pre><code>{'axes.prop_cycle': cycler('color', ['#5790fc', '#f89c20', '#e42536', '#964a8b', '#9c9ca1', '#7a21dd']), 'font.sans-serif': ['TeX Gyre Heros', 'Helvetica', 'Arial'], 'font.family': 'sans-serif', 'mathtext.fontset': 'custom', 'mathtext.rm': 'TeX Gyre Heros', 'mathtext.bf': 'TeX Gyre Heros:bold', 'mathtext.sf': 'TeX Gyre Heros', 'mathtext.it': 'TeX Gyre Heros:italic', 'mathtext.tt': 'TeX Gyre Heros', 'mathtext.cal': 'TeX Gyre Heros', 'mathtext.default': 'regular', 'figure.figsize': (10.0, 10.0), 'font.size': 26, 'axes.labelsize': 'medium', 'axes.unicode_minus': False, 'xtick.labelsize': 'small', 'ytick.labelsize': 'small', 'legend.fontsize': 'small', 'legend.handlelength': 1.5, 'legend.borderpad': 0.5, 'legend.frameon': False, 'xtick.direction': 'in', 'xtick.major.size': 12, 'xtick.minor.size': 6, 'xtick.major.pad': 6, 'xtick.top': True, 'xtick.major.top': True, 'xtick.major.bottom': True, 'xtick.minor.top': True, 'xtick.minor.bottom': True, 'xtick.minor.visible': True, 'ytick.direction': 'in', 'ytick.major.size': 12, 'ytick.minor.size': 6.0, 'ytick.right': True, 'ytick.major.left': True, 'ytick.major.right': True, 'ytick.minor.left': True, 'ytick.minor.right': True, 'ytick.minor.visible': True, 'grid.alpha': 0.8, 'grid.linestyle': ':', 'axes.linewidth': 2, 'savefig.transparent': False, 'xaxis.labellocation': 'right', 'yaxis.labellocation': 'top'}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.CMS, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('ATLAS')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.ATLAS)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.ATLAS)\n</code></pre> <pre><code>{'font.size': 14, 'font.family': 'sans-serif', 'font.sans-serif': ['TeX Gyre Heros', 'helvetica', 'Helvetica', 'Nimbus Sans L', 'Mukti Narrow', 'FreeSans'], 'font.serif': ['Tex Gyre Termes', 'Times', 'Times Roman', 'Times New Roman', 'Nimbus Roman'], 'font.monospace': ['Tex Gyre Cursor', 'Courier', 'Courier New', 'Nimbus Mono'], 'figure.figsize': (8.0, 6.0), 'figure.dpi': 100, 'figure.facecolor': '#FFFFFF', 'figure.subplot.bottom': 0.16, 'figure.subplot.top': 0.93, 'figure.subplot.left': 0.16, 'figure.subplot.right': 0.95, 'axes.titlesize': 'xx-large', 'axes.labelsize': 'x-large', 'axes.linewidth': 1, 'axes.grid': False, 'axes.axisbelow': False, 'axes.labelpad': 10, 'axes.facecolor': '#FFFFFF', 'axes.labelcolor': '#000000', 'axes.formatter.limits': '-2, 4', 'axes.formatter.use_mathtext': True, 'axes.autolimit_mode': 'round_numbers', 'axes.unicode_minus': False, 'axes.xmargin': 0.0, 'xaxis.labellocation': 'right', 'yaxis.labellocation': 'top', 'xtick.direction': 'in', 'xtick.minor.visible': True, 'xtick.top': True, 'xtick.bottom': True, 'xtick.major.top': True, 'xtick.major.bottom': True, 'xtick.minor.top': True, 'xtick.minor.bottom': True, 'xtick.labelsize': 'large', 'xtick.major.size': 5, 'xtick.minor.size': 3, 'xtick.color': '#000000', 'ytick.direction': 'in', 'ytick.left': True, 'ytick.right': True, 'ytick.major.left': True, 'ytick.major.right': True, 'ytick.minor.left': True, 'ytick.minor.right': True, 'ytick.minor.visible': True, 'ytick.labelsize': 'large', 'ytick.major.size': 14, 'ytick.minor.size': 7, 'lines.linewidth': 2, 'lines.markersize': 8, 'legend.numpoints': 1, 'legend.fontsize': 'medium', 'legend.title_fontsize': 'medium', 'legend.labelspacing': 0.3, 'legend.frameon': False, 'legend.handlelength': 2, 'legend.borderpad': 1.0, 'savefig.transparent': False, 'axes.prop_cycle': cycler('color', ['#d55e00', '#56b4e9', '#e69f00', '#f0e442', '#009e73', '#cc79a7', '#0072b2']), 'mathtext.fontset': 'custom', 'mathtext.rm': 'TeX Gyre Heros', 'mathtext.bf': 'TeX Gyre Heros:bold', 'mathtext.sf': 'TeX Gyre Heros', 'mathtext.it': 'TeX Gyre Heros:italic', 'mathtext.tt': 'TeX Gyre Heros', 'mathtext.cal': 'TeX Gyre Heros', 'mathtext.default': 'it'}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.ATLAS, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('LHCb2')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.LHCb2)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.LHCb2)\n</code></pre> <pre><code>{'axes.labelsize': 32, 'axes.linewidth': 2, 'axes.facecolor': 'white', 'axes.xmargin': 0.0, 'axes.prop_cycle': cycler('color', ['#0078FF', '#FF6600', '#0AAFB6', '#FF3333', '#0000FF', '#00CC00', '#BF8040', '#FF33CC', '#FF7733', '#BFD1D4']), 'axes.formatter.min_exponent': 3, 'axes.titlesize': 28, 'errorbar.capsize': 2.5, 'figure.figsize': (12, 9), 'figure.dpi': 100, 'figure.facecolor': 'white', 'font.family': 'serif', 'font.serif': ['Tex Gyre Termes'], 'font.cursive': ['Tex Gyre Termes'], 'mathtext.fontset': 'custom', 'mathtext.rm': 'Tex Gyre Termes', 'mathtext.bf': 'Tex Gyre Termes:bold', 'mathtext.sf': 'Tex Gyre Termes', 'mathtext.it': 'Tex Gyre Termes:italic', 'mathtext.tt': 'Tex Gyre Termes', 'mathtext.cal': 'Tex Gyre Termes', 'font.size': 14, 'font.weight': 400, 'legend.frameon': False, 'legend.fancybox': True, 'legend.facecolor': 'inherit', 'legend.numpoints': 1, 'legend.labelspacing': 0.2, 'legend.fontsize': 28, 'legend.title_fontsize': 28, 'legend.loc': 'best', 'legend.handletextpad': 0.75, 'legend.borderaxespad': 1.0, 'lines.linewidth': 3.3, 'lines.markeredgewidth': 1.5, 'lines.markersize': 16, 'savefig.bbox': 'tight', 'savefig.pad_inches': 0.1, 'savefig.format': 'pdf', 'xtick.minor.visible': True, 'xtick.top': True, 'xtick.major.size': 14, 'xtick.minor.size': 7, 'xtick.major.width': 2, 'xtick.minor.width': 2, 'xtick.major.pad': 10, 'xtick.minor.pad': 10, 'xtick.labelsize': 30, 'xtick.direction': 'in', 'ytick.minor.visible': True, 'ytick.right': True, 'ytick.major.size': 14, 'ytick.minor.size': 7, 'ytick.major.width': 2, 'ytick.minor.width': 2, 'ytick.major.pad': 10, 'ytick.minor.pad': 10, 'ytick.labelsize': 30, 'ytick.direction': 'in', 'patch.linewidth': 2, 'xaxis.labellocation': 'right', 'yaxis.labellocation': 'top'}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.LHCb2, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('ALICE')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.ALICE)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.ALICE)\n</code></pre> <pre><code>{'lines.linewidth': 1, 'font.family': 'sans-serif', 'font.sans-serif': ['TeX Gyre Heros', 'Helvetica', 'Arial'], 'font.size': 14, 'mathtext.fontset': 'stixsans', 'mathtext.default': 'rm', 'figure.figsize': (12.0, 9.0), 'figure.facecolor': 'white', 'figure.subplot.bottom': 0.16, 'figure.subplot.top': 0.93, 'figure.subplot.left': 0.16, 'figure.subplot.right': 0.95, 'axes.labelsize': 32, 'axes.labelpad': 24, 'xtick.top': True, 'xtick.labelsize': 25, 'xtick.major.size': 10, 'xtick.minor.size': 5, 'xtick.direction': 'in', 'xtick.minor.visible': True, 'ytick.right': True, 'ytick.labelsize': 25, 'ytick.major.size': 14, 'ytick.minor.size': 7, 'ytick.direction': 'in', 'ytick.minor.visible': True, 'lines.markersize': 8, 'legend.loc': 'best', 'legend.numpoints': 1, 'legend.fontsize': 28, 'legend.labelspacing': 0.3, 'legend.frameon': False, 'xaxis.labellocation': 'right', 'yaxis.labellocation': 'top'}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.ALICE, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> Style by nameStyle as a dictWith customizations <pre><code>mh.style.use('DUNE')\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Styles are simple dictionaries that configure <code>mpl.rcParams</code>.</p> <pre><code>mh.style.use(mh.style.DUNE)\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\nprint(mh.style.DUNE)\n</code></pre> <pre><code>{'font.sans-serif': ['TeX Gyre Heros', 'Helvetica', 'Helvetica Neue', 'Nimbus Sans L', 'Liberation Sans', 'Arial', 'FreeSans'], 'font.family': 'sans-serif', 'mathtext.fontset': 'custom', 'mathtext.rm': 'TeX Gyre Heros', 'mathtext.bf': 'TeX Gyre Heros:bold', 'mathtext.sf': 'TeX Gyre Heros', 'mathtext.it': 'TeX Gyre Heros:italic', 'mathtext.tt': 'TeX Gyre Heros', 'mathtext.cal': 'TeX Gyre Heros', 'mathtext.default': 'regular', 'figure.figsize': (10, 10), 'figure.facecolor': 'white', 'figure.dpi': 100, 'figure.autolayout': True, 'text.hinting_factor': 8, 'font.size': 22, 'axes.facecolor': 'white', 'axes.edgecolor': 'black', 'axes.grid': False, 'axes.linewidth': 1.5, 'axes.labelsize': 'medium', 'axes.titlesize': 36, 'axes.formatter.use_mathtext': True, 'axes.unicode_minus': False, 'axes.xmargin': 0.0, 'axes.prop_cycle': cycler('color', ['#000000', '#D55E00', '#56B4E9', '#E69F00', '#009E73', '#CC79A7', '#0072B2', '#F0E442']), 'lines.linewidth': 2.0, 'lines.markersize': 8, 'patch.linewidth': 1.5, 'patch.facecolor': 'blue', 'patch.edgecolor': 'black', 'patch.antialiased': True, 'image.cmap': 'cividis', 'image.aspect': 'auto', 'grid.color': '#b2b2b2', 'grid.linestyle': ':', 'grid.linewidth': 0.5, 'grid.alpha': 0.8, 'legend.fontsize': 12, 'legend.title_fontsize': 'large', 'legend.frameon': False, 'legend.handlelength': 2.0, 'legend.borderpad': 0.8, 'legend.columnspacing': 1.0, 'legend.labelspacing': 0.5, 'legend.loc': 'best', 'xtick.color': 'black', 'xtick.direction': 'in', 'xtick.labelsize': 'small', 'xtick.major.size': 10, 'xtick.minor.size': 5, 'xtick.major.pad': 6, 'xtick.minor.visible': True, 'xtick.top': True, 'xtick.bottom': True, 'xtick.major.top': True, 'xtick.major.bottom': True, 'xtick.minor.top': True, 'xtick.minor.bottom': True, 'ytick.color': 'black', 'ytick.direction': 'in', 'ytick.labelsize': 'small', 'ytick.major.size': 10, 'ytick.minor.size': 5, 'ytick.major.pad': 6, 'ytick.minor.visible': True, 'ytick.right': True, 'ytick.left': True, 'ytick.major.left': True, 'ytick.major.right': True, 'ytick.minor.left': True, 'ytick.minor.right': True, 'xaxis.labellocation': 'right', 'yaxis.labellocation': 'top', 'savefig.transparent': False, 'savefig.bbox': 'tight'}\n</code></pre> <p>By passing a list <code>[\"CMS\", {...}]</code> users can overwrite settings as they see fit.</p> <pre><code>mh.style.use([mh.style.DUNE, {\"font.size\": 10,}])\n\nfig, ax = plt.subplots()\nmh.histplot([1, 2, 3, 6, 3, 5, 2, 1], ax=ax)\n</code></pre> <p>Warning</p> <p>Due to matplotlib limitations, <code>with plt.style.context()</code> does not work reliably with mplhep styles, especially for fonts. Use <code>mh.style.use()</code> globally instead.</p>"},{"location":"guide_styling/#setting-experiment-labels","title":"Setting experiment labels","text":"<p>Each experiment style comes with a matching label function that formats experiment names, status text, and run information according to that experiment's guidelines:</p> DefaultplothistCMSATLASLHCbALICEDUNE loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, lumi=100, ax=ax, loc=0, supp='arXiv:2024.12345')\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, lumi=100, ax=ax, loc=1, supp='arXiv:2024.12345')\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, lumi=100, ax=ax, loc=2, supp='arXiv:2024.12345')\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, lumi=100, ax=ax, loc=3, supp='arXiv:2024.12345')\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, lumi=100, ax=ax, loc=4, supp='arXiv:2024.12345')\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, lumi=150, ax=ax, loc=0, supp='arXiv:2024.12345')\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, lumi=150, ax=ax, loc=1, supp='arXiv:2024.12345')\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, lumi=150, ax=ax, loc=2, supp='arXiv:2024.12345')\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, lumi=150, ax=ax, loc=3, supp='arXiv:2024.12345')\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, lumi=150, ax=ax, loc=4, supp='arXiv:2024.12345')\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, lumi=50, ax=ax, loc=0, supp='arXiv:2024.12345')\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, lumi=50, ax=ax, loc=1, supp='arXiv:2024.12345')\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, lumi=50, ax=ax, loc=2, supp='arXiv:2024.12345')\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, lumi=50, ax=ax, loc=3, supp='arXiv:2024.12345')\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, lumi=50, ax=ax, loc=4, supp='arXiv:2024.12345')\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, lumi=100, ax=ax, loc=0, supp='arXiv:2024.12345')\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, lumi=100, ax=ax, loc=1, supp='arXiv:2024.12345')\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, lumi=100, ax=ax, loc=2, supp='arXiv:2024.12345')\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, lumi=100, ax=ax, loc=3, supp='arXiv:2024.12345')\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, lumi=100, ax=ax, loc=4, supp='arXiv:2024.12345')\n</code></pre> loc=0 (Above axes)loc=1 (Top left, single line)loc=2 (Top left, multiline)loc=3 (Split layout)loc=4 (Style-specific) <p>Default for most experiments. Label appears above the plot area, left aligned.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, lumi=100, ax=ax, loc=0, supp='arXiv:2024.12345')\n</code></pre> <p>Compact single-line format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, lumi=100, ax=ax, loc=1, supp='arXiv:2024.12345')\n</code></pre> <p>Multiline format in the top left corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, lumi=100, ax=ax, loc=2, supp='arXiv:2024.12345')\n</code></pre> <p>Experiment name above axes, secondary text in corner.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, lumi=100, ax=ax, loc=3, supp='arXiv:2024.12345')\n</code></pre> <p>Style-specific layout (e.g., ATLAS places luminosity below).</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, lumi=100, ax=ax, loc=4, supp='arXiv:2024.12345')\n</code></pre>"},{"location":"guide_styling/#configuring-experiment-labels","title":"Configuring experiment labels","text":"<p>Additional configuration options for experiment labels:</p> DefaultplothistCMSATLASLHCbALICEDUNE Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\n# No label function for default style\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\ntxt_obj = mh.add_text('plothist', loc='over left', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\ntxt_obj = mh.add_text('Custom Text', loc='over left', ax=ax)\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label('Preliminary', data=True, year='2023', lumi=137.2, com=13, lumi_format='{0:.1f}', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.cms.label(llabel='Left Label', rlabel='Right Label', ax=ax)\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label('Preliminary', data=True, year='2023', lumi=150, com=13, lumi_format='{0:.0f}', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.atlas.label(llabel='Left Label', rlabel='Right Label', ax=ax)\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label('Preliminary', data=True, year='2023', lumi=50, com=13, lumi_format='{0:.0f}', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.lhcb.label(llabel='Left Label', rlabel='Right Label', ax=ax)\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label('Preliminary', data=True, year='2023', lumi=100, com=13, lumi_format='{0:.0f}', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.alice.label(llabel='Left Label', rlabel='Right Label', ax=ax)\n</code></pre> Common configurationsFully customized <p>Combine multiple standard parameters for complete label information.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label('Preliminary', data=True, year='2023', lumi=100, lumi_format='{0:.0f}', ax=ax)\n</code></pre> <p>Use <code>llabel</code> and <code>rlabel</code> for complete control over label content.</p> <pre><code>fig, ax = plt.subplots()\nax.plot([0, 1, 2], [0, 1, 4])\nmh.dune.label(llabel='Left Label', rlabel='Right Label', ax=ax)\n</code></pre>"},{"location":"guide_utilities/","title":"Utilities","text":"<p>This section covers advanced mplhep features and utilities.</p> Prerequisites <p>Throughout this guide the following codeblock is assumed. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport hist\nnp.random.seed(42)\nimport mplhep as mh\n# mh.style.use('&lt;as appropriate&gt;')\n</code></pre></p>"},{"location":"guide_utilities/#text-placement","title":"Text placement","text":""},{"location":"guide_utilities/#add-text","title":"Add text","text":"<p>mh.add_text will add text to a specified location on the axis. It has flexible positioning options, that are accessible via the <code>loc</code> argument, or the <code>x</code> and <code>y</code> arguments.</p> DefaultplothistCMSATLASLHCbALICEDUNE loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre> loc argumentx and y arguments <pre><code>fig, ax = plt.subplots()\n\nlocs = [\n \"upper left\", # or \"top left\"\n \"upper right\", # or \"top right\"\n \"lower left\", # or \"bottom left\"\n \"lower right\", # or \"bottom right\"\n \"over left\",\n \"over right\",\n \"under left\",\n \"under right\",\n]\n\nfor loc in locs:\n mh.add_text(\n f'Text with\\nloc=\"{loc}\"',\n loc=loc,\n ax=ax,\n )\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\npositions = [\n (\"right_in\", \"top_in\"),\n (\"left_in\", \"top_in\"),\n (\"left_in\", \"bottom_in\"),\n (\"right_in\", \"bottom_in\"),\n (\"right\", \"top_out\"),\n (\"left\", \"top_out\"),\n (\"right_out\", \"top_in\"),\n (\"right_out\", \"bottom_in\"),\n (\"right\", \"bottom_out\"),\n (\"left\", \"bottom_out\"),\n]\n\nfor x, y in positions:\n mh.add_text(\n f'Text with\\nx=\"{x}\"\\ny=\"{y}\"',\n x=x,\n y=y,\n ax=ax,\n )\n</code></pre>"},{"location":"guide_utilities/#append-text","title":"Append text","text":"<p>mh.append_text appends additional text relative to an existing text object created with mh.add_text. The new text can be positioned above, below, left, or right of the existing text.</p> <pre><code># Add text at specific location\ntxt = mh.add_text('Custom Text', loc='upper right')\n\n# Append additional text\nmh.append_text('Additional info', txt, loc='below')\n</code></pre>"},{"location":"guide_utilities/#subplot-creation","title":"Subplot creation","text":"<p>mh.subplots is a wrapper around <code>plt.subplots</code> to create a figure with multiple subplots. It conveniently adjusts the figure size and spacing between subplots if multiple rows are requested.</p> <pre><code>fig, axes = mh.subplots(nrows=6)\n# Will scale the figure, and add spacing between rows and remove the xlabels on inner plots.\n</code></pre>"},{"location":"guide_utilities/#save-variations","title":"Save variations","text":"<p>mh.savelabels automatically generates multiple versions of a plot with different experiment label text variations, useful for creating preliminary and final versions of plots.</p> <pre><code>mh.savelabels('test.png')\n# Produces: test.png, test_pas.png, test_supp.png, test_wip.png, with no label, 'Preliminary', 'Supplementary', and 'Work in Progress' labels respectively.\n\nmh.savelabels('test', labels=[(\"FOO\", \"foo.pdf\"), (\"BAR\", \"bar\")])\n# Produces: foo.pdf, test_bar.png\n</code></pre>"},{"location":"guide_utilities/#fit-y-label","title":"Fit y-label","text":"<p>mh.set_fitting_ylabel_fontsize adjusts the y-axis label font size to fit within the figure when there are long y-axis labels.</p> <pre><code>mh.set_fitting_ylabel_fontsize(ax)\n</code></pre>"},{"location":"guide_utilities/#mpl_magic","title":"mpl_magic","text":"<p>The function mh.mpl_magic applies several common mplhep utilities to a given axis:</p> <ul> <li>mh.set_ylow: Sets a minimum y-axis limit based on data.</li> <li>mh.yscale_legend: Rescales the y-axis to fit the legend.</li> <li>mh.yscale_anchored_text: Rescales the y-axis to fit anchored text.</li> </ul> <pre><code>mh.mpl_magic(ax)\n</code></pre> <p>You can also call these functions individually as needed.</p>"},{"location":"guide_utilities/#axes-manipulation","title":"Axes manipulation","text":""},{"location":"guide_utilities/#add-colorbar-axis","title":"Add colorbar axis","text":"<p>mh.make_square_add_cbar creates a square axis and adds a colorbar axis to the right, useful for 2D histograms.</p> <pre><code>ax_colorbar = mh.make_square_add_cbar(ax)\n# ax is now square, and ax_colorbar is the colorbar axis.\n</code></pre>"},{"location":"guide_utilities/#add-axis","title":"Add axis","text":"<p>mh.append_axes appends a new axis to an existing axis in a specified direction (top, bottom, left, right).</p> <pre><code>ax_new = mh.append_axes(ax, position='top', size=2, pad=0.3)\n# Adds a new axis above ax with height 2 inches and 0.3 inch padding.\n</code></pre>"},{"location":"guide_utilities/#plthist-wrapper","title":"plt.hist wrapper","text":"<p>mh.hist is a drop-in replacement for mh.histplot which runs the <code>np.histogram</code> function before plotting. It provides a convenient way to create a histogram of raw data values and benefits from the extended features of mh.histplot, such as automatic error bar calculation, bin-width normalization and HEP-style plotting options.</p> <p>Warning</p> <p>mh.hist does not return a histogram object compatible with the Unified Histogram Interface (UHI), thus cannot be used directly with other mplhep histogram plotting functions.</p> <pre><code>data = np.random.normal(100, 15, 1000)\nmh.hist(data, bins=50, range=(50, 150))\n\n# Multiple datasets\ndata1 = np.random.normal(100, 15, 1000)\ndata2 = np.random.normal(120, 15, 1000)\nmh.hist([data1, data2], bins=50, label=['Dataset 1', 'Dataset 2'])\n</code></pre>"},{"location":"gallery/1d_comparison_asymmetry/","title":"1D Comparison Asymmetry","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"asymmetry\",  # &lt;--\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"asymmetry\",  # &lt;--\n)\n</code></pre>"},{"location":"gallery/1d_comparison_difference/","title":"1D Comparison Difference","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"difference\",  # &lt;--\n)\n\nmh.add_text(\n    \"Comparison of two hist with difference plot\",\n    ax=ax_main,\n    fontsize=\"small\",\n    loc=\"over left\",\n)\nmh.add_text(\"Difference ax\", ax=ax_comparison, loc=\"over right\", fontsize=\"small\")\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"difference\",  # &lt;--\n)\n\nmh.add_text(\n    \"Comparison of two hist with difference plot\",\n    ax=ax_main,\n    fontsize=\"small\",\n    loc=\"over left\",\n)\nmh.add_text(\"Difference ax\", ax=ax_comparison, loc=\"over right\", fontsize=\"small\")\n</code></pre>"},{"location":"gallery/1d_comparison_efficiency/","title":"1D Comparison Efficiency","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data - sample is subset of total\nx_total = np.random.normal(0.4, 0.1, 10000)\nx_sample = x_total[:7500]  # 75% subset\n\n# Create and fill histograms\nh_sample = hist.new.Regular(50, 0, 1).Weight().fill(x_sample)\nh_total = hist.new.Regular(50, 0, 1).Weight().fill(x_total)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h_sample,\n    h_total,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_{Sample}$\",\n    h2_label=r\"$h_{Total}$\",\n    comparison=\"efficiency\",  # &lt;--\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data - sample is subset of total\nx_total = np.random.normal(0.4, 0.1, 10000)\nx_sample = x_total[:7500]  # 75% subset\n\n# Create and fill histograms\nh_sample = hist.new.Regular(50, 0, 1).Weight().fill(x_sample)\nh_total = hist.new.Regular(50, 0, 1).Weight().fill(x_total)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h_sample,\n    h_total,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_{Sample}$\",\n    h2_label=r\"$h_{Total}$\",\n    comparison=\"efficiency\",  # &lt;--\n)\n</code></pre>"},{"location":"gallery/1d_comparison_only_efficiency/","title":"1D Comparison Only Efficiency","text":"Imports <pre><code>import hist\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data - sample is subset of total\nx_total = np.random.normal(0.4, 0.1, 10000)\nx_sample = x_total[:7500]  # 75% subset\n\n# Create and fill histograms\nh_sample = hist.new.Regular(50, 0, 1).Weight().fill(x_sample)\nh_total = hist.new.Regular(50, 0, 1).Weight().fill(x_total)\n</code></pre> <p>Code</p> <pre><code>fig, ax = plt.subplots()\nmh.comp.comparison(h_sample, h_total, ax=ax, xlabel=\"Variable\", comparison=\"efficiency\")\n</code></pre> Full code <pre><code>import hist\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data - sample is subset of total\nx_total = np.random.normal(0.4, 0.1, 10000)\nx_sample = x_total[:7500]  # 75% subset\n\n# Create and fill histograms\nh_sample = hist.new.Regular(50, 0, 1).Weight().fill(x_sample)\nh_total = hist.new.Regular(50, 0, 1).Weight().fill(x_total)\n\nfig, ax = plt.subplots()\nmh.comp.comparison(h_sample, h_total, ax=ax, xlabel=\"Variable\", comparison=\"efficiency\")\n</code></pre>"},{"location":"gallery/1d_comparison_pull/","title":"1D Comparison Pull","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"pull\",  # &lt;---\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"pull\",  # &lt;---\n)\n</code></pre>"},{"location":"gallery/1d_comparison_ratio/","title":"1D Comparison Ratio","text":"<p>This example shows how to plot the comparison between two 1D histograms using the ratio.</p> <p></p> Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"ratio\",  # &lt;--\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"ratio\",  # &lt;--\n)\n</code></pre>"},{"location":"gallery/1d_comparison_relative_difference/","title":"1D Comparison Relative Difference","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"relative_difference\",  # &lt;--\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"relative_difference\",  # &lt;--\n)\n</code></pre>"},{"location":"gallery/1d_comparison_split_ratio/","title":"1D Comparison Split Ratio","text":"Imports <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"split_ratio\",\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Generate dummy data\nx1 = np.r_[np.random.normal(0.4, 0.1, 5000), np.random.normal(0.7, 0.1, 5000)]\nx2 = np.r_[np.random.normal(0.4, 0.1, 1000), np.random.normal(0.7, 0.11, 7000)]\n\n# Create and fill histograms\nh1 = hist.new.Regular(50, 0, 1).Weight().fill(x1)\nh2 = hist.new.Regular(50, 0, 1).Weight().fill(x2)\n\nfig, ax_main, ax_comparison = mh.comp.hists(\n    h1,\n    h2,\n    xlabel=\"Variable\",\n    ylabel=\"Entries\",\n    h1_label=r\"$h_1$\",\n    h2_label=r\"$h_2$\",\n    comparison=\"split_ratio\",\n)\n</code></pre>"},{"location":"gallery/model_all_comparisons/","title":"Model All Comparisons","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram with mixed components\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 300),\n        ]\n    )\n)\n\n# Create background component histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n</code></pre> <p>Code</p> <pre><code>fig, axes = mh.subplots(nrows=6, hspace=0.3)\n\nmh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"\",\n    ylabel=\"Entries\",\n    comparison=\"ratio\",\n    fig=fig,\n    ax_main=axes[0],\n    ax_comparison=axes[1],\n)\n\nmh.add_text(\n    r\"Multiple data-model comparisons, $\\mathbf{with}$ model uncertainty\",\n    ax=axes[0],\n    loc=\"over left\",\n    fontsize=\"small\",\n)\nmh.add_text(\n    r'  $\\mathbf{\u2192}$ comparison = \"ratio\"', ax=axes[1], loc=\"over left\", fontsize=13\n)\n\n# Add remaining comparison types\nfor k, comp in enumerate(\n    [\"split_ratio\", \"pull\", \"relative_difference\", \"difference\"], start=2\n):\n    mh.comp.comparison(\n        data_hist,\n        sum(background_hists),\n        ax=axes[k],\n        comparison=comp,\n        xlabel=\"\",\n        h1_label=\"Data\",\n        h2_label=\"MC\",\n        h1_w2method=\"poisson\",\n    )\n    mh.add_text(\n        rf'  $\\mathbf{{\u2192}}$ comparison = \"{comp}\"',\n        ax=axes[k],\n        fontsize=13,\n        loc=\"over left\",\n    )\n    mh.set_fitting_ylabel_fontsize(axes[k])\n\naxes[-1].set_xlabel(\"Observable\")\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram with mixed components\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 300),\n        ]\n    )\n)\n\n# Create background component histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\nfig, axes = mh.subplots(nrows=6, hspace=0.3)\n\nmh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"\",\n    ylabel=\"Entries\",\n    comparison=\"ratio\",\n    fig=fig,\n    ax_main=axes[0],\n    ax_comparison=axes[1],\n)\n\nmh.add_text(\n    r\"Multiple data-model comparisons, $\\mathbf{with}$ model uncertainty\",\n    ax=axes[0],\n    loc=\"over left\",\n    fontsize=\"small\",\n)\nmh.add_text(\n    r'  $\\mathbf{\u2192}$ comparison = \"ratio\"', ax=axes[1], loc=\"over left\", fontsize=13\n)\n\n# Add remaining comparison types\nfor k, comp in enumerate(\n    [\"split_ratio\", \"pull\", \"relative_difference\", \"difference\"], start=2\n):\n    mh.comp.comparison(\n        data_hist,\n        sum(background_hists),\n        ax=axes[k],\n        comparison=comp,\n        xlabel=\"\",\n        h1_label=\"Data\",\n        h2_label=\"MC\",\n        h1_w2method=\"poisson\",\n    )\n    mh.add_text(\n        rf'  $\\mathbf{{\u2192}}$ comparison = \"{comp}\"',\n        ax=axes[k],\n        fontsize=13,\n        loc=\"over left\",\n    )\n    mh.set_fitting_ylabel_fontsize(axes[k])\n\naxes[-1].set_xlabel(\"Observable\")\n</code></pre>"},{"location":"gallery/model_all_comparisons_no_model_unc/","title":"Model All Comparisons No Model Uncertainty","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n</code></pre> Setup <pre><code># Set seed for reproducible demo\nnp.random.seed(42)\n\n# Create demo histograms directly\nbins = np.linspace(-9, 12, 51)\n\n# Background components with different shapes\nbkg1_data = np.random.normal(0, 2.5, 4000)  # Broad background\nbkg2_data = np.random.normal(3, 1.2, 2000)  # Narrower peak\nbkg3_data = np.random.normal(-1, 1.8, 1500)  # Another component\n\n# Data = backgrounds + signal peak + some deficit\ndata_data = np.concatenate(\n    [\n        np.random.normal(0, 2.5, 3500),  # Less background here\n        np.random.normal(3, 1.2, 1800),  # Similar background\n        np.random.normal(-1, 1.8, 1400),  # Similar background\n        np.random.normal(0, 0.8, 500),  # Clear signal peak\n        np.random.normal(-3, 0.5, 200),  # Some deficit here (under-predicted)\n    ]\n)\n\n# Create histograms\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(data_data)\n\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg1_data),\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg2_data),\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg3_data),\n]\n\n# Scale backgrounds to match data\ntotal_bkg = sum(background_hists).sum().value\ndata_total = data_hist.sum().value\nscale_factor = data_total / total_bkg\nbackground_hists = [scale_factor * h for h in background_hists]\n\n# Labels and colors\nbackground_labels = [\"Broad BG\", \"Peak BG\", \"Offset BG\"]\nbackground_colors = sns.color_palette(\"cubehelix\", 3)\n\n# Scale backgrounds to match data\ntotal_bkg = sum(background_hists).sum().value\ndata_total = data_hist.sum().value\nscale_factor = data_total / total_bkg\nbackground_hists = [scale_factor * h for h in background_hists]\n\n# Labels and colors\nbackground_labels = [\"Background 1\", \"Background 2\", \"Background 3\"]\nbackground_colors = sns.color_palette(\"cubehelix\", 3)\n</code></pre> <p>Code</p> <pre><code># Create comparison plots\nfig, axes = mh.subplots(nrows=6, hspace=0.3)\n\nbackground_sum = sum(background_hists)\n\nmh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=background_labels,\n    stacked_colors=background_colors,\n    xlabel=\"\",\n    ylabel=\"Entries\",\n    model_uncertainty=False,  # &lt;--\n    comparison=\"ratio\",\n    fig=fig,\n    ax_main=axes[0],\n    ax_comparison=axes[1],\n)\n\nmh.add_text(\n    r\"Multiple data-model comparisons, $\\mathbf{without}$ model uncertainty\",\n    ax=axes[0],\n    loc=\"over left\",\n    fontsize=\"small\",\n)\nmh.add_text(\n    r'  $\\mathbf{\u2192}$ comparison = \"ratio\"', ax=axes[1], loc=\"over left\", fontsize=13\n)\n\nfor k_comp, comp in enumerate(\n    [\"split_ratio\", \"pull\", \"relative_difference\", \"difference\"], start=2\n):\n    ax_comparison = axes[k_comp]\n\n    # Copy the original histogram and set the uncertainties of the copy to 0.\n    background_sum_copy = background_sum.copy()\n    background_sum_copy[:] = np.c_[\n        background_sum_copy.values(), np.zeros_like(background_sum_copy.values())\n    ]\n\n    mh.comp.comparison(\n        data_hist,\n        background_sum_copy,\n        ax=ax_comparison,\n        comparison=comp,\n        xlabel=\"\",\n        h1_label=\"Data\",\n        h2_label=\"MC\",\n        h1_w2method=\"poisson\",\n    )\n    if comp == \"pull\":\n        # Since the uncertainties of the model are neglected, the pull label is \"(Data - MC)/sigma_Data\"\n        ax_comparison.set_ylabel(r\"$\\frac{Data-MC}{\\sigma_{Data}}$\")\n    mh.add_text(\n        rf'  $\\mathbf{{\u2192}}$ comparison = \"{comp}\"',\n        ax=ax_comparison,\n        loc=\"over left\",\n        fontsize=13,\n    )\n    mh.set_fitting_ylabel_fontsize(ax_comparison)\n\naxes[-1].set_xlabel(\"Observable\")\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\n\n# Set seed for reproducible demo\nnp.random.seed(42)\n\n# Create demo histograms directly\nbins = np.linspace(-9, 12, 51)\n\n# Background components with different shapes\nbkg1_data = np.random.normal(0, 2.5, 4000)  # Broad background\nbkg2_data = np.random.normal(3, 1.2, 2000)  # Narrower peak\nbkg3_data = np.random.normal(-1, 1.8, 1500)  # Another component\n\n# Data = backgrounds + signal peak + some deficit\ndata_data = np.concatenate(\n    [\n        np.random.normal(0, 2.5, 3500),  # Less background here\n        np.random.normal(3, 1.2, 1800),  # Similar background\n        np.random.normal(-1, 1.8, 1400),  # Similar background\n        np.random.normal(0, 0.8, 500),  # Clear signal peak\n        np.random.normal(-3, 0.5, 200),  # Some deficit here (under-predicted)\n    ]\n)\n\n# Create histograms\ndata_hist = hist.new.Regular(50, -8, 8).Weight().fill(data_data)\n\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg1_data),\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg2_data),\n    hist.new.Regular(50, -8, 8).Weight().fill(bkg3_data),\n]\n\n# Scale backgrounds to match data\ntotal_bkg = sum(background_hists).sum().value\ndata_total = data_hist.sum().value\nscale_factor = data_total / total_bkg\nbackground_hists = [scale_factor * h for h in background_hists]\n\n# Labels and colors\nbackground_labels = [\"Broad BG\", \"Peak BG\", \"Offset BG\"]\nbackground_colors = sns.color_palette(\"cubehelix\", 3)\n\n# Scale backgrounds to match data\ntotal_bkg = sum(background_hists).sum().value\ndata_total = data_hist.sum().value\nscale_factor = data_total / total_bkg\nbackground_hists = [scale_factor * h for h in background_hists]\n\n# Labels and colors\nbackground_labels = [\"Background 1\", \"Background 2\", \"Background 3\"]\nbackground_colors = sns.color_palette(\"cubehelix\", 3)\n\n# Create comparison plots\nfig, axes = mh.subplots(nrows=6, hspace=0.3)\n\nbackground_sum = sum(background_hists)\n\nmh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=background_labels,\n    stacked_colors=background_colors,\n    xlabel=\"\",\n    ylabel=\"Entries\",\n    model_uncertainty=False,  # &lt;--\n    comparison=\"ratio\",\n    fig=fig,\n    ax_main=axes[0],\n    ax_comparison=axes[1],\n)\n\nmh.add_text(\n    r\"Multiple data-model comparisons, $\\mathbf{without}$ model uncertainty\",\n    ax=axes[0],\n    loc=\"over left\",\n    fontsize=\"small\",\n)\nmh.add_text(\n    r'  $\\mathbf{\u2192}$ comparison = \"ratio\"', ax=axes[1], loc=\"over left\", fontsize=13\n)\n\nfor k_comp, comp in enumerate(\n    [\"split_ratio\", \"pull\", \"relative_difference\", \"difference\"], start=2\n):\n    ax_comparison = axes[k_comp]\n\n    # Copy the original histogram and set the uncertainties of the copy to 0.\n    background_sum_copy = background_sum.copy()\n    background_sum_copy[:] = np.c_[\n        background_sum_copy.values(), np.zeros_like(background_sum_copy.values())\n    ]\n\n    mh.comp.comparison(\n        data_hist,\n        background_sum_copy,\n        ax=ax_comparison,\n        comparison=comp,\n        xlabel=\"\",\n        h1_label=\"Data\",\n        h2_label=\"MC\",\n        h1_w2method=\"poisson\",\n    )\n    if comp == \"pull\":\n        # Since the uncertainties of the model are neglected, the pull label is \"(Data - MC)/sigma_Data\"\n        ax_comparison.set_ylabel(r\"$\\frac{Data-MC}{\\sigma_{Data}}$\")\n    mh.add_text(\n        rf'  $\\mathbf{{\u2192}}$ comparison = \"{comp}\"',\n        ax=ax_comparison,\n        loc=\"over left\",\n        fontsize=13,\n    )\n    mh.set_fitting_ylabel_fontsize(ax_comparison)\n\naxes[-1].set_xlabel(\"Observable\")\n</code></pre>"},{"location":"gallery/model_examples_pull/","title":"Model Examples Pull","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 2000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=r\"$m_{\\ell\\ell}\\,\\,[TeV/c^2]$\",\n    ylabel=\"Candidates per 0.42 $TeV/c^2$\",\n    comparison=\"pull\",\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 2000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=r\"$m_{\\ell\\ell}\\,\\,[TeV/c^2]$\",\n    ylabel=\"Candidates per 0.42 $TeV/c^2$\",\n    comparison=\"pull\",\n)\n</code></pre>"},{"location":"gallery/model_examples_pull_no_model_unc/","title":"Model Examples Pull No Model Uncertainty","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 2000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=r\"$m_{\\ell\\ell}\\,\\,[TeV/c^2]$\",\n    ylabel=r\"Hits in the LMN per $4.2\\times 10^{-1}\\,\\,eV/c^2$\",\n    comparison=\"pull\",\n    model_uncertainty=False,  # &lt;--\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 2000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=r\"$m_{\\ell\\ell}\\,\\,[TeV/c^2]$\",\n    ylabel=r\"Hits in the LMN per $4.2\\times 10^{-1}\\,\\,eV/c^2$\",\n    comparison=\"pull\",\n    model_uncertainty=False,  # &lt;--\n)\n</code></pre>"},{"location":"gallery/model_examples_stacked/","title":"Model Examples Stacked","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\n# Create signal histogram (not part of the model)\nsignal_hist = hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-1, 0.5, 400))\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n)\n\n# Signal histogram not part of the model and therefore not included in the comparison\nmh.histplot(signal_hist, ax=ax_main, color=\"red\", label=\"Signal\", histtype=\"step\")\nax_main.legend()\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\n# Create signal histogram (not part of the model)\nsignal_hist = hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-1, 0.5, 400))\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n)\n\n# Signal histogram not part of the model and therefore not included in the comparison\nmh.histplot(signal_hist, ax=ax_main, color=\"red\", label=\"Signal\", histtype=\"step\")\nax_main.legend()\n</code></pre>"},{"location":"gallery/model_examples_stacked_unstacked/","title":"Model Examples Stacked Unstacked","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists[:2],\n    stacked_labels=[\"c0\", \"c1\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3)[:2],\n    unstacked_components=background_hists[2:],\n    unstacked_labels=[\"c2\"],\n    unstacked_colors=[sns.color_palette(\"cubehelix\", 3)[2]],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    comparison_ylim=(0.5, 1.5),\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=background_hists[:2],\n    stacked_labels=[\"c0\", \"c1\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3)[:2],\n    unstacked_components=background_hists[2:],\n    unstacked_labels=[\"c2\"],\n    unstacked_colors=[sns.color_palette(\"cubehelix\", 3)[2]],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    comparison_ylim=(0.5, 1.5),\n)\n</code></pre>"},{"location":"gallery/model_examples_unstacked/","title":"Model Examples Unstacked","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    unstacked_components=background_hists,\n    unstacked_labels=[\"c0\", \"c1\", \"c2\"],\n    unstacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"label\": \"Sum(hists)\", \"color\": \"navy\"},\n    comparison_ylim=[0.5, 1.5],\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3000),\n            np.random.normal(-3, 0.8, 1500),\n            np.random.normal(-2, 1.5, 1200),\n            np.random.normal(0, 0.5, 500),\n        ]\n    )\n)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Scale backgrounds to match data\nscale = data_hist.sum().value / sum(background_hists).sum().value\nbackground_hists = [scale * h for h in background_hists]\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    unstacked_components=background_hists,\n    unstacked_labels=[\"c0\", \"c1\", \"c2\"],\n    unstacked_colors=sns.color_palette(\"cubehelix\", 3),\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"label\": \"Sum(hists)\", \"color\": \"navy\"},\n    comparison_ylim=[0.5, 1.5],\n)\n</code></pre>"},{"location":"gallery/model_with_stacked_and_unstacked_function_components/","title":"Model With Stacked And Unstacked Function Components","text":"Imports <pre><code>from scipy.stats import norm\n\nimport mplhep as mh\n</code></pre> Setup <pre><code># Define model function components\ndef f_signal(x):\n    return 600 * norm.pdf(x, loc=0.2, scale=3)\n\n\ndef f_background1(x):\n    return 1000 * norm.pdf(x, loc=-1.5, scale=4)\n\n\ndef f_background2(x):\n    return 3000 * norm.pdf(x, loc=-3.2, scale=1.2)\n</code></pre> <p>Code</p> <pre><code>fig, ax = mh.model(\n    stacked_components=[f_background1, f_background2],\n    stacked_labels=[\"c0\", \"c1\"],\n    unstacked_components=[f_signal],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"black\"],\n    xlabel=\"Observable\",\n    ylabel=\"f(Observable)\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    function_range=(-9, 12),\n)\n\nmh.add_text(\"Model made of functions\", ax=ax, loc=\"over left\", fontsize=\"small\")\n</code></pre> Full code <pre><code>from scipy.stats import norm\n\nimport mplhep as mh\n\n\n\n# Define model function components\ndef f_signal(x):\n    return 600 * norm.pdf(x, loc=0.2, scale=3)\n\n\ndef f_background1(x):\n    return 1000 * norm.pdf(x, loc=-1.5, scale=4)\n\n\ndef f_background2(x):\n    return 3000 * norm.pdf(x, loc=-3.2, scale=1.2)\n\n\n\nfig, ax = mh.model(\n    stacked_components=[f_background1, f_background2],\n    stacked_labels=[\"c0\", \"c1\"],\n    unstacked_components=[f_signal],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"black\"],\n    xlabel=\"Observable\",\n    ylabel=\"f(Observable)\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    function_range=(-9, 12),\n)\n\nmh.add_text(\"Model made of functions\", ax=ax, loc=\"over left\", fontsize=\"small\")\n</code></pre>"},{"location":"gallery/model_with_stacked_and_unstacked_histograms_components/","title":"Model With Stacked And Unstacked Histograms Components","text":"Imports <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Create signal histogram\nsignal_hist = hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 0.5, 500))\n</code></pre> <p>Code</p> <pre><code>fig, ax = mh.model(\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    unstacked_components=[signal_hist],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"black\"],\n    unstacked_kwargs_list=[{\"linestyle\": \"dotted\"}],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    model_uncertainty_label=\"Stat. unc.\",\n)\n\nmh.add_text(\"Model made of histograms\", ax=ax, loc=\"over left\")\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nimport seaborn as sns\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n# Create background histograms\nbackground_hists = [\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 2, 3500)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-3, 0.8, 1800)),\n    hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(-2, 1.5, 1400)),\n]\n\n# Create signal histogram\nsignal_hist = hist.new.Regular(50, -8, 8).Weight().fill(np.random.normal(0, 0.5, 500))\n\nfig, ax = mh.model(\n    stacked_components=background_hists,\n    stacked_labels=[\"c0\", \"c1\", \"c2\"],\n    stacked_colors=sns.color_palette(\"cubehelix\", 3),\n    unstacked_components=[signal_hist],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"black\"],\n    unstacked_kwargs_list=[{\"linestyle\": \"dotted\"}],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    model_uncertainty_label=\"Stat. unc.\",\n)\n\nmh.add_text(\"Model made of histograms\", ax=ax, loc=\"over left\")\n</code></pre>"},{"location":"gallery/ratio_data_vs_model_with_stacked_and_unstacked_function_components/","title":"Ratio Data Vs Model With Stacked And Unstacked Function Components","text":"Imports <pre><code>import hist\nimport numpy as np\nfrom scipy.stats import norm\n\nimport mplhep as mh\n\nnp.random.seed(42)\n</code></pre> Setup <pre><code># Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3500),\n            np.random.normal(-3, 1, 2000),\n            np.random.normal(5, 0.5, 200),\n        ]\n    )\n)\n_binwidth = data_hist.axes[0].widths[0]\n\n\n# Define model function components\ndef f_signal(x):\n    return 200 * _binwidth * norm.pdf(x, loc=5, scale=0.5)\n\n\ndef f_background1(x):\n    return 3500 * _binwidth * norm.pdf(x, loc=0, scale=2)\n\n\ndef f_background2(x):\n    return 2000 * _binwidth * norm.pdf(x, loc=-3, scale=1)\n</code></pre> <p>Code</p> <pre><code>fig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=[f_background1, f_background2],\n    stacked_labels=[\"c0\", \"c1\"],\n    unstacked_components=[f_signal],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"#8EBA42\"],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    comparison=\"pull\",\n)\n</code></pre> Full code <pre><code>import hist\nimport numpy as np\nfrom scipy.stats import norm\n\nimport mplhep as mh\n\nnp.random.seed(42)\n\n\n# Create data histogram\ndata_hist = hist.new.Regular(50, -8, 8).Weight()\ndata_hist.fill(\n    np.concatenate(\n        [\n            np.random.normal(0, 2, 3500),\n            np.random.normal(-3, 1, 2000),\n            np.random.normal(5, 0.5, 200),\n        ]\n    )\n)\n_binwidth = data_hist.axes[0].widths[0]\n\n\n# Define model function components\ndef f_signal(x):\n    return 200 * _binwidth * norm.pdf(x, loc=5, scale=0.5)\n\n\ndef f_background1(x):\n    return 3500 * _binwidth * norm.pdf(x, loc=0, scale=2)\n\n\ndef f_background2(x):\n    return 2000 * _binwidth * norm.pdf(x, loc=-3, scale=1)\n\n\n\nfig, ax_main, ax_comparison = mh.comp.data_model(\n    data_hist=data_hist,\n    stacked_components=[f_background1, f_background2],\n    stacked_labels=[\"c0\", \"c1\"],\n    unstacked_components=[f_signal],\n    unstacked_labels=[\"Signal\"],\n    unstacked_colors=[\"#8EBA42\"],\n    xlabel=\"Observable\",\n    ylabel=\"Entries\",\n    model_sum_kwargs={\"show\": True, \"label\": \"Model\", \"color\": \"navy\"},\n    comparison=\"pull\",\n)\n</code></pre>"}]}